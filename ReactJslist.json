{"postlist":[{"title":"Render and Commit","author":"Jay.J","date":"2024-06-19T00:00:00.000Z","categories":["javascript","ReactJs"],"tags":["javascript","ReactJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/react.png","url":"/post/2024-06-19-2_3_Render_and_Commit","con":"---\r\n\r\n<br>\r\n\r\n## Render and Commit\r\n> 렌더링 그리고 커밋\r\n\r\n UI를 요청하고 제공하는데까지 세 단계로 나눌 수 있다.<br>\r\n 음식점이라고 상상하고 이 단계들을 표현해보겠다.\r\n\r\n1. 렌더링 <b>트리거</b> (손님의 주문을 주방으로 전달)\r\n2. 컴포넌트 <b>렌더링</b> (주방에서 주문 준비하기)\r\n3. DOM에 <b>커밋</b> (테이블에 주문한 요리 내놓기)\r\n\r\n<br>\r\n\r\n<img src=\"/assets/img/react/i_rerender.png\" alt=\"\" style=\"max-width:500px\">\r\n\r\n<br>\r\n\r\n### 1단계: 렌더링 트리거\r\n컴포넌트 렌더링이 일어나는 데에는 두 가지 이유가 있다.\r\n\r\n1. 컴포넌트의 초기 렌더링인 경우\r\n2. 컴포넌트의 state가 업데이트된 경우\r\n\r\n#### 초기 렌더링\r\n\r\n앱을 시작할 때 초기 렌더링을 트리거해야 한다<br>\r\nDOM 노드와 함께 ```createRoot"},{"title":"State as a Snapshot","author":"Jay.J","date":"2024-06-19T00:00:00.000Z","categories":["javascript","ReactJs"],"tags":["javascript","ReactJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/react.png","url":"/post/2024-06-19-2_4_State_as_a_Snapshot","con":"---\r\n\r\n<br>\r\n\r\n## State as a Snapshot\r\n> 스냅샷으로서의 State\r\n\r\n### state를 설정하면 렌더링이 동작한다\r\n클릭과 같은 사용자 이벤트에 반응하여 사용자 인터페이스가 직접 변경된다고 생각할 수 있다.\r\n\r\n```js\r\nimport { useState } from 'react';\r\n\r\nexport default function Form() {\r\n  const [isSent, setIsSent] = useState(false);\r\n  const [message, setMessage] = useState('Hi!');\r\n  if (isSent) {\r\n    return <h1>Your message is on its way!</h1>\r\n  }\r\n  return (\r\n    <form onSubmit={(e) => {\r\n      e.preventDefault();\r\n      setIsSent(true);\r\n      sendMessage(mes"},{"title":"Queueing a Series of State Updates","author":"Jay.J","date":"2024-06-19T00:00:00.000Z","categories":["javascript","ReactJs"],"tags":["javascript","ReactJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/react.png","url":"/post/2024-06-19-2_5_Queueing_a_Series_of_State_Updates","con":"---\r\n\r\n<br>\r\n\r\n## Queueing a Series of State Updates\r\n> state 업데이트 큐\r\n\r\n### React state batches 업데이트\r\n```setNumber(number + 1)```를 세 번 호출하므로 “+3” 버튼을 클릭하면 세 번 증가할 것으로 예상할 수 있다.\r\n\r\n```js\r\nimport { useState } from 'react';\r\n\r\nexport default function Counter() {\r\n  const [number, setNumber] = useState(0);\r\n\r\n  return (\r\n    <>\r\n      <h1>{number}</h1>\r\n      <button onClick={() => {\r\n        setNumber(number + 1);\r\n        setNumber(number + 1);\r\n        setNumber(number + 1);\r\n      }}>+3</button>"},{"title":"Updating Objects in State","author":"Jay.J","date":"2024-06-19T00:00:00.000Z","categories":["javascript","ReactJs"],"tags":["javascript","ReactJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/react.png","url":"/post/2024-06-19-2_6_Updating_objects_in_state","con":"---\r\n\r\n<br>\r\n\r\n## Updating Objects in State\r\n> 객체 State 업데이트하기\r\n\r\n### 변경이란?\r\nState에는 모든 종류의 자바스크립트 값을 저장할 수 있다.\r\n\r\n```js\r\nconst [x, setX] = useState(0);\r\nsetX(5);\r\n```\r\nx에 들어가는 값들은 변경할 수 없거나 “읽기 전용”을 의미하는 “불변성”을 가진다.<br/>\r\n값을 교체 하기 위해서는 리렌더링이 필요한다.(<b>setX를 이용</b>)<br/>\r\nx state는 0에서 5로 바뀌었지만, 숫자 0 자체 는 바뀌지 않았다.<br/>\r\n숫자, 문자열, 불리언과 같이 자바스크립트에 정의되어 있는 원시 값들은 변경할 수 없다.\r\n\r\n<br>\r\n\r\n```js\r\nconst [position, setPosition] = useState({ x: 0, y: 0 });\r\n```\r\n기술적으로 객체 자체 의 내용은 바꿀 수 있다.<br>\r\n이것을 <b>변경(mutati"},{"title":"Updating Arrays In State","author":"Jay.J","date":"2024-06-19T00:00:00.000Z","categories":["javascript","ReactJs"],"tags":["javascript","ReactJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/react.png","url":"/post/2024-06-19-2_7_Updating-arrays-in-state","con":"---\r\n\r\n<br>\r\n\r\n## Updating Arrays In State\r\n> 배열 State 업데이트하기\r\n\r\n### 변경하지 않고 배열 업데이트하기\r\n객체와 마찬가지로 React state에서 배열은 읽기 전용으로 처리해야 한다.<br>\r\n즉 ```arr[0] = 'bird'```처럼 배열 내부의 항목을 재할당해서는 안 되며 ```push()```나 ```pop()```같은 함수로 배열을 변경해서는 안된다.<br>\r\n<br>\r\n배열을 업데이트할 때마다 ```filter()```나 ```map()```을 이용하여 새 배열을 state 설정 함수에 전달해야 한다.\r\n<br>\r\n\r\n<table>\r\n  <caption>Updating Arrays In State</caption>\r\n  <thead>\r\n    <tr>\r\n      <th scope='col'></th>\r\n      <th scope='col'>비선호(배열을 변경)</th>\r\n      <th scope='col'>선호"},{"title":"Responding to Events","author":"Jay.J","date":"2024-06-18T00:00:00.000Z","categories":["javascript","ReactJs"],"tags":["javascript","ReactJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/react.png","url":"/post/2024-06-18-2_1_Responding_to_Events","con":"---\r\n\r\n<br>\r\n\r\n## Responding to Events\r\n> 이벤트에 응답하기\r\n\r\n<br>\r\n\r\n### 이벤트 핸들러 추가하기\r\n이벤트 핸들러 추가를 위해서는 먼저 함수를 정의하고 이를 적절한 JSX 태그에 prop 형태로 전달해야 한다.\r\n\r\n```js\r\nexport default function Button() {\r\n  function handleClick() {\r\n    alert('You clicked me!');\r\n  }\r\n\r\n  return (\r\n    <button onClick={handleClick}>\r\n      Click me\r\n    </button>\r\n  );\r\n}\r\n```\r\n>Button 컴포넌트 내부에 handleClick 함수를 선언한다.<br>\r\n>해당 함수 내부 로직을 구현합니다. 이번에는 메시지를 표시하기 위해 alert를 사용한다.<br>\r\n>```<button>``` JSX에 ```onClick={handleClick}```을 추"},{"title":"State A Components Memory","author":"Jay.J","date":"2024-06-18T00:00:00.000Z","categories":["javascript","ReactJs"],"tags":["javascript","ReactJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/react.png","url":"/post/2024-06-18-2_2_State_A_Components_Memory","con":"---\r\n\r\n<br>\r\n\r\n## State: A Components Memory\r\n> State: 컴포넌트의 기억 저장소\r\n\r\n<br>\r\n\r\n### 일반 변수로 충분하지 않은 경우\r\n```js\r\nimport { sculptureList } from './data.js';\r\n\r\nexport default function Gallery() {\r\n  let index = 0;\r\n\r\n  function handleClick() {\r\n    index = index + 1;\r\n  }\r\n\r\n  let sculpture = sculptureList[index];\r\n  return (\r\n    <>\r\n      <button onClick={handleClick}>\r\n        Next\r\n      </button>\r\n      <h2>\r\n        <i>{sculpture.name} </i> \r\n        by {sculpture.artist}\r\n      </h2>\r\n      <h"},{"title":"Your First Component","author":"Jay.J","date":"2024-06-17T00:00:00.000Z","categories":["javascript","ReactJs"],"tags":["javascript","ReactJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/react.png","url":"/post/2024-06-17-1_1_Your_First_Component","con":"---\r\n\r\n<br>\r\n\r\n## Your First Component\r\n> 첫번째 컴포넌트\r\n<br>\r\n\r\n### 컴포넌트: UI 구성 요소 \r\n\r\nReact에서의 컴포넌트 : 마크업, CSS, JavaScript를 앱의 재사용 가능한 사용자 정의 UI 요소.<br>\r\n컴포넌트를 작성, 순서 지정 및 중첩하여 전체 페이지를 디자인할 수 있다.\r\n\r\n<br>\r\n\r\n### 컴포넌트 정의하기\r\n\r\nReact 컴포넌트는 마크업으로 뿌릴 수 있는 JavaScript 함수이다. <br/>\r\n\r\n```js\r\nexport default function Profile() {\r\n  return (\r\n    <img\r\n      src=\"https://i.imgur.com/MK3eW3Am.jpg\"\r\n      alt=\"Katherine Johnson\"\r\n    />\r\n  )\r\n}\r\n\r\n```\r\n\r\n<br>\r\n\r\n#### Step 1: 컴포넌트 내보내기\r\nexport 를 이용하여 내보낸다.<br>\r\n``"},{"title":"Your First Component","author":"Jay.J","date":"2024-06-17T00:00:00.000Z","categories":["javascript","ReactJs"],"tags":["javascript","ReactJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/react.png","url":"/post/2024-06-17-1_2_Importing_and_Exporting_Componentsy","con":"---\r\n\r\n<br>\r\n\r\n## Importing and Exporting Components\r\n> 컴포넌트 import 및 export 하기\r\n<br>\r\n\r\n### Root 컴포넌트란\r\n\r\nApp.js 라는 파일이 대부분 만들어지고 이게 루트이며, 모든 컴포넌트는 이런 루트 안에 존재하게된다.<br/>\r\n만약 Next.js 같은 프레임워크일 경우, 매 페이지 마다 Root component 가 달라진다.\r\n\r\n<br>\r\n\r\n### 컴포넌트를 import 하거나 export 하는 방법\r\n\r\n1. 컴포넌트를 추가할 JS 파일을 생성한다.\r\n2. 새로 만든 파일에서 함수 컴포넌트를 export 한다.\r\n> default 또는 named export 방식을 사용한다.\r\n3. 컴포넌트를 사용할 파일에서 import 한다.\r\n> 적절한 방식을 선택해서 default 또는 named로 import 한다.\r\n\r\n```js\r\nimport Gallery from './Gallery.js';\r\n\r\ne"},{"title":"Writing Markup with JSX","author":"Jay.J","date":"2024-06-17T00:00:00.000Z","categories":["javascript","ReactJs"],"tags":["javascript","ReactJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/react.png","url":"/post/2024-06-17-1_3_Writing_Markup_with_JSX","con":"---\r\n\r\n<br>\r\n\r\n## Writing Markup with JSX\r\n> 첫번째 컴포넌트\r\n<br>\r\n\r\n### JSX: JavaScript에 마크업 넣기\r\n원래의 Web은 HTML, CSS, JavaScript를 기반으로써,<br>\r\nHTML로 내용을, CSS로 디자인을, JavaScript로 로직을 작성하면서 각각 별도의 파일로 관리했다.<br>\r\n<br>\r\n그러나 Web이 더욱 인터랙티브해지면서 로직이 내용을 결정하는 경우가 많아졌고, 그래서 JavaScript가 HTML을 담당하게 되었다 !<br>\r\n이것이 바로 React에서 <b>렌더링 로직과 마크업이 같은 위치(컴포넌트)에 함께 있게 된 이유</b>이다. \r\n<br>\r\n로직과 마크업이 공존하면 서로 싱크를 맞추기가 수월하다.<br>\r\n그리고 각 컨포넌트의 렌더링 로직/html 을 분리해서 관리 할 수 있어서 서로 관여를 없앨 수 있다.<br>\r\nReact 컴포넌트는 JSX라는 확장된 문법을 사용하여 마크업을 나타낸"},{"title":"Render_and_Commit","author":"Jay.J","date":"2024-06-17T00:00:00.000Z","categories":["javascript","ReactJs"],"tags":["javascript","ReactJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/react.png","url":"/post/2024-06-17-1_4_JavaScript_in_JSX_with_Curly_Braces","con":"---\r\n\r\n<br>\r\n\r\n## Render_and_Commit\r\n> 렌더링 그리고 커밋\r\n<br>\r\n\r\n### 따옴표로 문자열 전달하기\r\n<br>\r\n1. 문자열 어트리뷰트를 JSX에 전달하려면 작은따옴표나 큰따옴표로 묶어야 한다.<br>\r\n\r\n```js\r\nexport default function Avatar() {\r\n  return (\r\n    <img\r\n      className=\"avatar\"\r\n      src=\"https://i.imgur.com/7vQD0fPs.jpg\"\r\n      alt=\"Gregorio Y. Zara\"\r\n    />\r\n  );\r\n}\r\n```\r\n\r\n<br>\r\n2. 어트리뷰트를 JSX에 동적으로 전달하려면 중괄호로 묶어야 한다.<br>\r\n\r\n```js\r\nexport default function Avatar() {\r\n  const avatar = 'https://i.imgur.com/7vQD0fPs.jpg';\r\n  const description = '"},{"title":"Passing Props to a Component","author":"Jay.J","date":"2024-06-17T00:00:00.000Z","categories":["javascript","ReactJs"],"tags":["javascript","ReactJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/react.png","url":"/post/2024-06-17-1_5_Passing_Props_to_a_Component","con":"---\r\n\r\n<br>\r\n\r\n## Passing Props to a Component\r\n> 컴포넌트에 props 전달하기\r\n<br>\r\n\r\n### 친숙한 props\r\nprops는 JSX 태그에 전달하는 정보이다.<br>\r\n예를 들어, className, src, alt, width, height는 ```<img>``` 태그에 전달할 수 있다.\r\n\r\n```js\r\nfunction Avatar() {\r\n  return (\r\n    <img\r\n      className=\"avatar\"\r\n      src=\"https://i.imgur.com/1bX5QH6.jpg\"\r\n      alt=\"Lin Lanying\"\r\n      width={100}\r\n      height={100}\r\n    />\r\n  );\r\n}\r\n\r\nexport default function Profile() {\r\n  return (\r\n    <Avatar />\r\n  );\r\n}\r\n```\r\n\r\n### 컴포넌트에 props 전달하기 "},{"title":"Conditional Rendering","author":"Jay.J","date":"2024-06-17T00:00:00.000Z","categories":["javascript","ReactJs"],"tags":["javascript","ReactJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/react.png","url":"/post/2024-06-17-1_6_Conditional_Rendering","con":"---\r\n\r\n<br>\r\n\r\n## Conditional Rendering\r\n> 조건부 렌더링\r\n<br>\r\n\r\n### 조건부로 JSX 반환하기\r\n```js\r\nfunction Item({ name, isPacked }) {\r\n  if (isPacked) {\r\n    return <li className=\"item\">{name} ✔</li>;\r\n  }\r\n  return <li className=\"item\">{name}</li>;\r\n}\r\n\r\nexport default function PackingList() {\r\n  return (\r\n    <section>\r\n      <h1>Sally Ride's Packing List</h1>\r\n      <ul>\r\n        <Item \r\n          isPacked={true} \r\n          name=\"Space suit\" \r\n        />\r\n        <Item \r\n          isPacked={true} \r\n    "},{"title":"Rendering Lists","author":"Jay.J","date":"2024-06-17T00:00:00.000Z","categories":["javascript","ReactJs"],"tags":["javascript","ReactJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/react.png","url":"/post/2024-06-18-1_7_Rendering_Lists","con":"---\r\n\r\n<br>\r\n\r\n## Rendering Lists\r\n> 리스트 렌더링\r\n<br>\r\n\r\n### 배열을 데이터로 렌더링하기\r\n\r\n#### 1. 데이터를 배열로 만든다.\r\n```js\r\nconst people = [\r\n  'Creola Katherine Johnson: mathematician',\r\n  'Mario José Molina-Pasquel Henríquez: chemist',\r\n  'Mohammad Abdus Salam: physicist',\r\n  'Percy Lavon Julian: chemist',\r\n  'Subrahmanyan Chandrasekhar: astrophysicist'\r\n];\r\n```\r\n\r\n#### 2. people의 요소를 새로운 JSX 노드 배열인 listItems에 매핑한다.\r\n```js\r\nconst listItems = people.map(person => <li>{person}</li>);\r\n```\r\n\r\n#### 3. ```<ul>```로 래"},{"title":"Keeping Components Pure","author":"Jay.J","date":"2024-06-17T00:00:00.000Z","categories":["javascript","ReactJs"],"tags":["javascript","ReactJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/react.png","url":"/post/2024-06-18-1_8_Keeping_Components_Pure","con":"---\r\n\r\n<br>\r\n\r\n## Keeping Components Pure\r\n> 컴포넌트 순수하게 유지하기\r\n<br>\r\n\r\n### 순수성: 공식으로서의 컴포넌트\r\n컴퓨터 과학에서(특히 함수형 프로그래밍의 세계에서는) 순수 함수는 다음과 같은 특징을 지니고 있는 함수이다.\r\n1. 자신의 일에 집중합니다. 함수가 호출되기 전에 존재했던 어떤 객체나 변수는 변경하지 않는다.\r\n2. 같은 입력, 같은 출력 같은 입력이 주어졌다면 순수함수는 같은 결과를 반환해야 한다.\r\n\r\n```js\r\n// 예시\r\nfunction double(number) {\r\n  return 2 * number;\r\n}\r\n```\r\n> React는 이러한 컨셉 기반에 설계되었다.<br>\r\n> React는 작성되는 모든 컴포넌트가 순수 함수일 거라 가정한다.\r\n<br>\r\n\r\n### 사이드 이펙트: 의도하지(않은) 결과 \r\nReact의 렌더링 과정은 항상 순수해야 한다.<br/>\r\n컴포넌트는 <b>렌더링하기 전에 존재했던 객체나"},{"title":"Understanding Your UI as a Tree","author":"Jay.J","date":"2024-06-17T00:00:00.000Z","categories":["javascript","ReactJs"],"tags":["javascript","ReactJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/react.png","url":"/post/2024-06-18-1_9_Understanding_Your_UI_as_a_Tree","con":"---\r\n\r\n<br>\r\n\r\n## Understanding Your UI as a Tree\r\n> 트리로서 UI 이해하기\r\n<br>\r\n\r\n### 트리로서의 UI\r\n데이터와 UI를 그릴때 트리구조가 많이 사용된다.\r\n- html → DOM\r\n- css → CSSOM \r\n\r\n모바일도 마찬가지로 계층구조를 트리로 만들어준다.\r\n\r\n<br>\r\n\r\n<img src=\"/assets/img/react/ui_tree.png\" alt=\"\" style=\"max-width:500px\">\r\n\r\n> React는 컴포넌트로부터 UI 트리를 생성한다.<br>\r\n> 위 예제 그림은 UI 트리는 DOM을 렌더링하는 데 사용됩니다.\r\n\r\n<br>\r\n브라우저와 모바일 플랫폼처럼 React도 React 앱의 컴포넌트 간의 관계를 관리하고 모델링하기 위해 트리 구조를 사용한다. <br>\r\n<b>트리는 데이터가 흐르는 방식과 렌더링 및 앱 크기를 최적화하는 방법을 이해하는 데 유용한 도구</b>이다.\r\n\r\n<br>\r\n\r\n##"},{"title":"React 프레임워크 - Next.js","author":"Jay.J","date":"2023-09-12T00:00:00.000Z","categories":["javascript","ReactJs","NextJs"],"tags":["javascript","ReactJs","NextJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/nextjs.png","url":"/post/2023-09-12-NextJs","con":"---\r\n\r\n<br>\r\n\r\nNext.js는 React 라이브러리의 프레임워크이다.<br>\r\nPre-Rendering, 서버 사이드 렌더링(Server Side Rendering - SSR), App Router, Code Splitting  같은 다양하고 풍부한 기능을 제공한다.<br>\r\n<br>\r\nReact는 클라이언트 사이드 렌더링(Client Side Rendering - CSR)으로 Search Engine Optimization(SEO)의 대응이 미흡하다.<br>\r\n그래서 <b>SEO를 대응하기 위해서 SSR 을 지원하는 Next.js를 사용</b>한다고 많은 포스트에서 작성하고 있다.\r\n\r\n## Next.js가 제공하는 기능들.\r\n\r\n### Pre-Rendering\r\n\r\n기본적으로 Next.js는 Static-Site Generate(SSG)와 Server Side Rendering(SSR)을 제공한다.<br>\r\n<br>\r\n두 가지 렌더링 호출 방식의 공통점은 <b>HTM"},{"title":"React_MUI","author":"Jay.J","date":"2023-07-10T00:00:00.000Z","categories":["javascript","ReactJs","MUI","css"],"tags":["javascript","ReactJs","MUI","css"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/mui.png","url":"/post/2023-07-10-React_MUI","con":"---\r\n\r\n<br>\r\n\r\n## MUI란\r\nMUI(Material UI)는 Material Design을 구현해놓은 라이브러리이다.<br>\r\n이 라이브러리를 이용하면 material 디자인 스타일이 적용된 UI를 매우 쉽게 구현할 수 있다. <br>\r\n<br>\r\n\r\n### Material Design이란?\r\n구글은 모바일과 데스크탑 그리고 그 외 다양한 디바이스들을 아우르는 하나의 일관된 디자인 가이드라인을 공개하였는데, 이것이 바로 <b>Material Design</b>이다.<br>\r\n<br>\r\n머티리얼 디자인은 질감이 느껴지는 표면 (tactile surfaces) 과 대담하고 선명한 그래픽 디자인 (bold graphic design), 그리고 아름답고 직관적인 사용자 경험을 위한 자연스러운 애니메이션을 특징으로 한다.\r\n\r\n<br>\r\n\r\n## MUI 설치하기\r\nMUI는 npm, yarn 등으로 설치할 수 있다.\r\n\r\n```js\r\n// npm\r\nnpm install @mui/"},{"title":"React란?","author":"Jay.J","date":"2023-03-07T00:00:00.000Z","categories":["javascript","ReactJs"],"tags":["javascript","ReactJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/react.png","url":"/post/2023-03-07-Reactjs","con":"---\r\n\r\n<br>\r\n\r\n## React.js 란 무엇인가?\r\nReact.js의 공식문서에서는 <b>'사용자 인터페이스를 만들기 위한 JavaScript 라이브러리'</b> 라고 설명하고 있다.<br>\r\n즉, 보여지는 화면을 만드는 자바스크립트 프레임워크 중의 하나이다.<br>\r\n\r\n> <a href=\"https://ko.legacy.reactjs.org/\" target=\"_blank\">React.js 공식사이트</a>\r\n\r\n<br>\r\n\r\n## 장점 및 특징\r\n1. Component 기반 구조\r\n2. Data Flow\r\n3. Virtual Dom\r\n4. JSX\r\n\r\n<Br>\r\n\r\n### Component 기반 구조\r\n\r\nVue.js 에서 한번 설명했던 구조이다.<br>\r\nDOM을 작은 단위로 쪼개어 개발하는 방식으로 유지보수와 재사용성이 높다.<br>\r\n<br>\r\n작은 단위로 쪼개져 있는 Dom 하나를 Component라 부르며, 독립된 Component들을 조립해 화면을 구성한다"}]}