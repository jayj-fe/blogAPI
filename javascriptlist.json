{"postlist":[{"title":"Render and Commit","author":"Jay.J","date":"2024-06-19T00:00:00.000Z","categories":["javascript","ReactJs"],"tags":["javascript","ReactJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/react.png","url":"/post/2024-06-19-2_3_Render_and_Commit","con":"---\r\n\r\n<br>\r\n\r\n## Render and Commit\r\n> 렌더링 그리고 커밋\r\n\r\n UI를 요청하고 제공하는데까지 세 단계로 나눌 수 있다.<br>\r\n 음식점이라고 상상하고 이 단계들을 표현해보겠다.\r\n\r\n1. 렌더링 <b>트리거</b> (손님의 주문을 주방으로 전달)\r\n2. 컴포넌트 <b>렌더링</b> (주방에서 주문 준비하기)\r\n3. DOM에 <b>커밋</b> (테이블에 주문한 요리 내놓기)\r\n\r\n<br>\r\n\r\n<img src=\"/assets/img/react/i_rerender.png\" alt=\"\" style=\"max-width:500px\">\r\n\r\n<br>\r\n\r\n### 1단계: 렌더링 트리거\r\n컴포넌트 렌더링이 일어나는 데에는 두 가지 이유가 있다.\r\n\r\n1. 컴포넌트의 초기 렌더링인 경우\r\n2. 컴포넌트의 state가 업데이트된 경우\r\n\r\n#### 초기 렌더링\r\n\r\n앱을 시작할 때 초기 렌더링을 트리거해야 한다<br>\r\nDOM 노드와 함께 ```createRoot"},{"title":"State as a Snapshot","author":"Jay.J","date":"2024-06-19T00:00:00.000Z","categories":["javascript","ReactJs"],"tags":["javascript","ReactJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/react.png","url":"/post/2024-06-19-2_4_State_as_a_Snapshot","con":"---\r\n\r\n<br>\r\n\r\n## State as a Snapshot\r\n> 스냅샷으로서의 State\r\n\r\n### state를 설정하면 렌더링이 동작한다\r\n클릭과 같은 사용자 이벤트에 반응하여 사용자 인터페이스가 직접 변경된다고 생각할 수 있다.\r\n\r\n```js\r\nimport { useState } from 'react';\r\n\r\nexport default function Form() {\r\n  const [isSent, setIsSent] = useState(false);\r\n  const [message, setMessage] = useState('Hi!');\r\n  if (isSent) {\r\n    return <h1>Your message is on its way!</h1>\r\n  }\r\n  return (\r\n    <form onSubmit={(e) => {\r\n      e.preventDefault();\r\n      setIsSent(true);\r\n      sendMessage(mes"},{"title":"Queueing a Series of State Updates","author":"Jay.J","date":"2024-06-19T00:00:00.000Z","categories":["javascript","ReactJs"],"tags":["javascript","ReactJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/react.png","url":"/post/2024-06-19-2_5_Queueing_a_Series_of_State_Updates","con":"---\r\n\r\n<br>\r\n\r\n## Queueing a Series of State Updates\r\n> state 업데이트 큐\r\n\r\n### React state batches 업데이트\r\n```setNumber(number + 1)```를 세 번 호출하므로 “+3” 버튼을 클릭하면 세 번 증가할 것으로 예상할 수 있다.\r\n\r\n```js\r\nimport { useState } from 'react';\r\n\r\nexport default function Counter() {\r\n  const [number, setNumber] = useState(0);\r\n\r\n  return (\r\n    <>\r\n      <h1>{number}</h1>\r\n      <button onClick={() => {\r\n        setNumber(number + 1);\r\n        setNumber(number + 1);\r\n        setNumber(number + 1);\r\n      }}>+3</button>"},{"title":"Updating Objects in State","author":"Jay.J","date":"2024-06-19T00:00:00.000Z","categories":["javascript","ReactJs"],"tags":["javascript","ReactJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/react.png","url":"/post/2024-06-19-2_6_Updating_objects_in_state","con":"---\r\n\r\n<br>\r\n\r\n## Updating Objects in State\r\n> 객체 State 업데이트하기\r\n\r\n### 변경이란?\r\nState에는 모든 종류의 자바스크립트 값을 저장할 수 있다.\r\n\r\n```js\r\nconst [x, setX] = useState(0);\r\nsetX(5);\r\n```\r\nx에 들어가는 값들은 변경할 수 없거나 “읽기 전용”을 의미하는 “불변성”을 가진다.<br/>\r\n값을 교체 하기 위해서는 리렌더링이 필요한다.(<b>setX를 이용</b>)<br/>\r\nx state는 0에서 5로 바뀌었지만, 숫자 0 자체 는 바뀌지 않았다.<br/>\r\n숫자, 문자열, 불리언과 같이 자바스크립트에 정의되어 있는 원시 값들은 변경할 수 없다.\r\n\r\n<br>\r\n\r\n```js\r\nconst [position, setPosition] = useState({ x: 0, y: 0 });\r\n```\r\n기술적으로 객체 자체 의 내용은 바꿀 수 있다.<br>\r\n이것을 <b>변경(mutati"},{"title":"Updating Arrays In State","author":"Jay.J","date":"2024-06-19T00:00:00.000Z","categories":["javascript","ReactJs"],"tags":["javascript","ReactJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/react.png","url":"/post/2024-06-19-2_7_Updating-arrays-in-state","con":"---\r\n\r\n<br>\r\n\r\n## Updating Arrays In State\r\n> 배열 State 업데이트하기\r\n\r\n### 변경하지 않고 배열 업데이트하기\r\n객체와 마찬가지로 React state에서 배열은 읽기 전용으로 처리해야 한다.<br>\r\n즉 ```arr[0] = 'bird'```처럼 배열 내부의 항목을 재할당해서는 안 되며 ```push()```나 ```pop()```같은 함수로 배열을 변경해서는 안된다.<br>\r\n<br>\r\n배열을 업데이트할 때마다 ```filter()```나 ```map()```을 이용하여 새 배열을 state 설정 함수에 전달해야 한다.\r\n<br>\r\n\r\n<table>\r\n  <caption>Updating Arrays In State</caption>\r\n  <thead>\r\n    <tr>\r\n      <th scope='col'></th>\r\n      <th scope='col'>비선호(배열을 변경)</th>\r\n      <th scope='col'>선호"},{"title":"Responding to Events","author":"Jay.J","date":"2024-06-18T00:00:00.000Z","categories":["javascript","ReactJs"],"tags":["javascript","ReactJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/react.png","url":"/post/2024-06-18-2_1_Responding_to_Events","con":"---\r\n\r\n<br>\r\n\r\n## Responding to Events\r\n> 이벤트에 응답하기\r\n\r\n<br>\r\n\r\n### 이벤트 핸들러 추가하기\r\n이벤트 핸들러 추가를 위해서는 먼저 함수를 정의하고 이를 적절한 JSX 태그에 prop 형태로 전달해야 한다.\r\n\r\n```js\r\nexport default function Button() {\r\n  function handleClick() {\r\n    alert('You clicked me!');\r\n  }\r\n\r\n  return (\r\n    <button onClick={handleClick}>\r\n      Click me\r\n    </button>\r\n  );\r\n}\r\n```\r\n>Button 컴포넌트 내부에 handleClick 함수를 선언한다.<br>\r\n>해당 함수 내부 로직을 구현합니다. 이번에는 메시지를 표시하기 위해 alert를 사용한다.<br>\r\n>```<button>``` JSX에 ```onClick={handleClick}```을 추"},{"title":"State A Components Memory","author":"Jay.J","date":"2024-06-18T00:00:00.000Z","categories":["javascript","ReactJs"],"tags":["javascript","ReactJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/react.png","url":"/post/2024-06-18-2_2_State_A_Components_Memory","con":"---\r\n\r\n<br>\r\n\r\n## State: A Components Memory\r\n> State: 컴포넌트의 기억 저장소\r\n\r\n<br>\r\n\r\n### 일반 변수로 충분하지 않은 경우\r\n```js\r\nimport { sculptureList } from './data.js';\r\n\r\nexport default function Gallery() {\r\n  let index = 0;\r\n\r\n  function handleClick() {\r\n    index = index + 1;\r\n  }\r\n\r\n  let sculpture = sculptureList[index];\r\n  return (\r\n    <>\r\n      <button onClick={handleClick}>\r\n        Next\r\n      </button>\r\n      <h2>\r\n        <i>{sculpture.name} </i> \r\n        by {sculpture.artist}\r\n      </h2>\r\n      <h"},{"title":"Your First Component","author":"Jay.J","date":"2024-06-17T00:00:00.000Z","categories":["javascript","ReactJs"],"tags":["javascript","ReactJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/react.png","url":"/post/2024-06-17-1_1_Your_First_Component","con":"---\r\n\r\n<br>\r\n\r\n## Your First Component\r\n> 첫번째 컴포넌트\r\n<br>\r\n\r\n### 컴포넌트: UI 구성 요소 \r\n\r\nReact에서의 컴포넌트 : 마크업, CSS, JavaScript를 앱의 재사용 가능한 사용자 정의 UI 요소.<br>\r\n컴포넌트를 작성, 순서 지정 및 중첩하여 전체 페이지를 디자인할 수 있다.\r\n\r\n<br>\r\n\r\n### 컴포넌트 정의하기\r\n\r\nReact 컴포넌트는 마크업으로 뿌릴 수 있는 JavaScript 함수이다. <br/>\r\n\r\n```js\r\nexport default function Profile() {\r\n  return (\r\n    <img\r\n      src=\"https://i.imgur.com/MK3eW3Am.jpg\"\r\n      alt=\"Katherine Johnson\"\r\n    />\r\n  )\r\n}\r\n\r\n```\r\n\r\n<br>\r\n\r\n#### Step 1: 컴포넌트 내보내기\r\nexport 를 이용하여 내보낸다.<br>\r\n``"},{"title":"Your First Component","author":"Jay.J","date":"2024-06-17T00:00:00.000Z","categories":["javascript","ReactJs"],"tags":["javascript","ReactJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/react.png","url":"/post/2024-06-17-1_2_Importing_and_Exporting_Componentsy","con":"---\r\n\r\n<br>\r\n\r\n## Importing and Exporting Components\r\n> 컴포넌트 import 및 export 하기\r\n<br>\r\n\r\n### Root 컴포넌트란\r\n\r\nApp.js 라는 파일이 대부분 만들어지고 이게 루트이며, 모든 컴포넌트는 이런 루트 안에 존재하게된다.<br/>\r\n만약 Next.js 같은 프레임워크일 경우, 매 페이지 마다 Root component 가 달라진다.\r\n\r\n<br>\r\n\r\n### 컴포넌트를 import 하거나 export 하는 방법\r\n\r\n1. 컴포넌트를 추가할 JS 파일을 생성한다.\r\n2. 새로 만든 파일에서 함수 컴포넌트를 export 한다.\r\n> default 또는 named export 방식을 사용한다.\r\n3. 컴포넌트를 사용할 파일에서 import 한다.\r\n> 적절한 방식을 선택해서 default 또는 named로 import 한다.\r\n\r\n```js\r\nimport Gallery from './Gallery.js';\r\n\r\ne"},{"title":"Writing Markup with JSX","author":"Jay.J","date":"2024-06-17T00:00:00.000Z","categories":["javascript","ReactJs"],"tags":["javascript","ReactJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/react.png","url":"/post/2024-06-17-1_3_Writing_Markup_with_JSX","con":"---\r\n\r\n<br>\r\n\r\n## Writing Markup with JSX\r\n> 첫번째 컴포넌트\r\n<br>\r\n\r\n### JSX: JavaScript에 마크업 넣기\r\n원래의 Web은 HTML, CSS, JavaScript를 기반으로써,<br>\r\nHTML로 내용을, CSS로 디자인을, JavaScript로 로직을 작성하면서 각각 별도의 파일로 관리했다.<br>\r\n<br>\r\n그러나 Web이 더욱 인터랙티브해지면서 로직이 내용을 결정하는 경우가 많아졌고, 그래서 JavaScript가 HTML을 담당하게 되었다 !<br>\r\n이것이 바로 React에서 <b>렌더링 로직과 마크업이 같은 위치(컴포넌트)에 함께 있게 된 이유</b>이다. \r\n<br>\r\n로직과 마크업이 공존하면 서로 싱크를 맞추기가 수월하다.<br>\r\n그리고 각 컨포넌트의 렌더링 로직/html 을 분리해서 관리 할 수 있어서 서로 관여를 없앨 수 있다.<br>\r\nReact 컴포넌트는 JSX라는 확장된 문법을 사용하여 마크업을 나타낸"},{"title":"Render_and_Commit","author":"Jay.J","date":"2024-06-17T00:00:00.000Z","categories":["javascript","ReactJs"],"tags":["javascript","ReactJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/react.png","url":"/post/2024-06-17-1_4_JavaScript_in_JSX_with_Curly_Braces","con":"---\r\n\r\n<br>\r\n\r\n## Render_and_Commit\r\n> 렌더링 그리고 커밋\r\n<br>\r\n\r\n### 따옴표로 문자열 전달하기\r\n<br>\r\n1. 문자열 어트리뷰트를 JSX에 전달하려면 작은따옴표나 큰따옴표로 묶어야 한다.<br>\r\n\r\n```js\r\nexport default function Avatar() {\r\n  return (\r\n    <img\r\n      className=\"avatar\"\r\n      src=\"https://i.imgur.com/7vQD0fPs.jpg\"\r\n      alt=\"Gregorio Y. Zara\"\r\n    />\r\n  );\r\n}\r\n```\r\n\r\n<br>\r\n2. 어트리뷰트를 JSX에 동적으로 전달하려면 중괄호로 묶어야 한다.<br>\r\n\r\n```js\r\nexport default function Avatar() {\r\n  const avatar = 'https://i.imgur.com/7vQD0fPs.jpg';\r\n  const description = '"},{"title":"Passing Props to a Component","author":"Jay.J","date":"2024-06-17T00:00:00.000Z","categories":["javascript","ReactJs"],"tags":["javascript","ReactJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/react.png","url":"/post/2024-06-17-1_5_Passing_Props_to_a_Component","con":"---\r\n\r\n<br>\r\n\r\n## Passing Props to a Component\r\n> 컴포넌트에 props 전달하기\r\n<br>\r\n\r\n### 친숙한 props\r\nprops는 JSX 태그에 전달하는 정보이다.<br>\r\n예를 들어, className, src, alt, width, height는 ```<img>``` 태그에 전달할 수 있다.\r\n\r\n```js\r\nfunction Avatar() {\r\n  return (\r\n    <img\r\n      className=\"avatar\"\r\n      src=\"https://i.imgur.com/1bX5QH6.jpg\"\r\n      alt=\"Lin Lanying\"\r\n      width={100}\r\n      height={100}\r\n    />\r\n  );\r\n}\r\n\r\nexport default function Profile() {\r\n  return (\r\n    <Avatar />\r\n  );\r\n}\r\n```\r\n\r\n### 컴포넌트에 props 전달하기 "},{"title":"Conditional Rendering","author":"Jay.J","date":"2024-06-17T00:00:00.000Z","categories":["javascript","ReactJs"],"tags":["javascript","ReactJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/react.png","url":"/post/2024-06-17-1_6_Conditional_Rendering","con":"---\r\n\r\n<br>\r\n\r\n## Conditional Rendering\r\n> 조건부 렌더링\r\n<br>\r\n\r\n### 조건부로 JSX 반환하기\r\n```js\r\nfunction Item({ name, isPacked }) {\r\n  if (isPacked) {\r\n    return <li className=\"item\">{name} ✔</li>;\r\n  }\r\n  return <li className=\"item\">{name}</li>;\r\n}\r\n\r\nexport default function PackingList() {\r\n  return (\r\n    <section>\r\n      <h1>Sally Ride's Packing List</h1>\r\n      <ul>\r\n        <Item \r\n          isPacked={true} \r\n          name=\"Space suit\" \r\n        />\r\n        <Item \r\n          isPacked={true} \r\n    "},{"title":"Rendering Lists","author":"Jay.J","date":"2024-06-17T00:00:00.000Z","categories":["javascript","ReactJs"],"tags":["javascript","ReactJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/react.png","url":"/post/2024-06-18-1_7_Rendering_Lists","con":"---\r\n\r\n<br>\r\n\r\n## Rendering Lists\r\n> 리스트 렌더링\r\n<br>\r\n\r\n### 배열을 데이터로 렌더링하기\r\n\r\n#### 1. 데이터를 배열로 만든다.\r\n```js\r\nconst people = [\r\n  'Creola Katherine Johnson: mathematician',\r\n  'Mario José Molina-Pasquel Henríquez: chemist',\r\n  'Mohammad Abdus Salam: physicist',\r\n  'Percy Lavon Julian: chemist',\r\n  'Subrahmanyan Chandrasekhar: astrophysicist'\r\n];\r\n```\r\n\r\n#### 2. people의 요소를 새로운 JSX 노드 배열인 listItems에 매핑한다.\r\n```js\r\nconst listItems = people.map(person => <li>{person}</li>);\r\n```\r\n\r\n#### 3. ```<ul>```로 래"},{"title":"Keeping Components Pure","author":"Jay.J","date":"2024-06-17T00:00:00.000Z","categories":["javascript","ReactJs"],"tags":["javascript","ReactJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/react.png","url":"/post/2024-06-18-1_8_Keeping_Components_Pure","con":"---\r\n\r\n<br>\r\n\r\n## Keeping Components Pure\r\n> 컴포넌트 순수하게 유지하기\r\n<br>\r\n\r\n### 순수성: 공식으로서의 컴포넌트\r\n컴퓨터 과학에서(특히 함수형 프로그래밍의 세계에서는) 순수 함수는 다음과 같은 특징을 지니고 있는 함수이다.\r\n1. 자신의 일에 집중합니다. 함수가 호출되기 전에 존재했던 어떤 객체나 변수는 변경하지 않는다.\r\n2. 같은 입력, 같은 출력 같은 입력이 주어졌다면 순수함수는 같은 결과를 반환해야 한다.\r\n\r\n```js\r\n// 예시\r\nfunction double(number) {\r\n  return 2 * number;\r\n}\r\n```\r\n> React는 이러한 컨셉 기반에 설계되었다.<br>\r\n> React는 작성되는 모든 컴포넌트가 순수 함수일 거라 가정한다.\r\n<br>\r\n\r\n### 사이드 이펙트: 의도하지(않은) 결과 \r\nReact의 렌더링 과정은 항상 순수해야 한다.<br/>\r\n컴포넌트는 <b>렌더링하기 전에 존재했던 객체나"},{"title":"Understanding Your UI as a Tree","author":"Jay.J","date":"2024-06-17T00:00:00.000Z","categories":["javascript","ReactJs"],"tags":["javascript","ReactJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/react.png","url":"/post/2024-06-18-1_9_Understanding_Your_UI_as_a_Tree","con":"---\r\n\r\n<br>\r\n\r\n## Understanding Your UI as a Tree\r\n> 트리로서 UI 이해하기\r\n<br>\r\n\r\n### 트리로서의 UI\r\n데이터와 UI를 그릴때 트리구조가 많이 사용된다.\r\n- html → DOM\r\n- css → CSSOM \r\n\r\n모바일도 마찬가지로 계층구조를 트리로 만들어준다.\r\n\r\n<br>\r\n\r\n<img src=\"/assets/img/react/ui_tree.png\" alt=\"\" style=\"max-width:500px\">\r\n\r\n> React는 컴포넌트로부터 UI 트리를 생성한다.<br>\r\n> 위 예제 그림은 UI 트리는 DOM을 렌더링하는 데 사용됩니다.\r\n\r\n<br>\r\n브라우저와 모바일 플랫폼처럼 React도 React 앱의 컴포넌트 간의 관계를 관리하고 모델링하기 위해 트리 구조를 사용한다. <br>\r\n<b>트리는 데이터가 흐르는 방식과 렌더링 및 앱 크기를 최적화하는 방법을 이해하는 데 유용한 도구</b>이다.\r\n\r\n<br>\r\n\r\n##"},{"title":"React의 상태관리 - Zustand","author":"Jay.J","date":"2023-12-10T00:00:00.000Z","categories":["javascript","ReactJs"],"tags":["javascript","ReactJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/react.png","url":"/post/2023-12-10-zustand","con":"---\r\n\r\n<br>\r\n\r\n## React의 상태관리 - Zustand\r\nReact에서 상태란 동적인 데이터이다.<br>\r\n동적인 데이터는 <b>데이터의 값이 변경되면 렌더링에 영향을 주는 값</b>이라고 할 수 있다.<br>\r\n<br>\r\n너무 잦은 상태의 변화는 잦은 렌더링이 이루어지기에 전체적인 성능저하가 일어날 수 있다.<br>\r\n또한 리액트는 단방향 바인딩으로, 부모 컴포넌트에서 자식 컴포넌트로만 state를 props로 전달할 수 있고, 반대로 부모 컴포넌트로 props를 직접 전달할 수는 없다.<br>\r\n자식 컴포넌트에서 부모 컴포넌트에 있는 state를 변경하려면 setState를 props로 넘겨줘야 한다.<br>\r\n코드 자체가 복잡해지고 상호 의존성이 많아져서 효율적이지 못하다.<br>\r\n<br>\r\n따라서 두 가지를 지키기 위하여 <b>상태관리</b>가 필요하다.\r\n1. 데이터가 바뀌어도 페이지가 렌더링 되지 않게 하기 위해\r\n2. 상태(state)들이 복잡하게 얽혀"},{"title":"FireBase - 데이터베이스 이용하기","author":"Jay.J","date":"2023-12-10T00:00:00.000Z","categories":["javascript","ReactJs","Firebase"],"tags":["javascript","ReactJs","Firebase"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/firebase.png","url":"/post/2023-12-22-firebase","con":"---\r\n\r\n<br>\r\n\r\n## FireBase - 데이터베이스 이용하기\r\n\r\n<br>\r\n\r\n### FireBase 란?\r\nFireBase는 2014년도에 구글에서 인수한 모바일, 웹 애플리케이션 개발 플랫폼이다.\r\nFirebase는 데이터베이스, 인증, 스토리지, 원격 구성, 푸시 알람 등다양한 기능을 제공한다.\r\n\r\n<br>\r\n\r\n### FireBase 시작하기\r\n1. <a href=\"https://firebase.google.com/?hl=ko\" target=\"_blank\">공식사이트</a>에 일단 가입해야한다.\r\n2. 공식사이트에서 로그인 후 console로 이동한다.<br>\r\n<img src=\"/assets/img/firebase/firebase.png\" style=\"max-width:500px\" alt=\"\">\r\n\r\n3. 새 프로젝트를 추가한다.<br>\r\n<img src=\"/assets/img/firebase/firebase2.png\" style=\"max-width:500p"},{"title":"React 프레임워크 - Next.js","author":"Jay.J","date":"2023-09-12T00:00:00.000Z","categories":["javascript","ReactJs","NextJs"],"tags":["javascript","ReactJs","NextJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/nextjs.png","url":"/post/2023-09-12-NextJs","con":"---\r\n\r\n<br>\r\n\r\nNext.js는 React 라이브러리의 프레임워크이다.<br>\r\nPre-Rendering, 서버 사이드 렌더링(Server Side Rendering - SSR), App Router, Code Splitting  같은 다양하고 풍부한 기능을 제공한다.<br>\r\n<br>\r\nReact는 클라이언트 사이드 렌더링(Client Side Rendering - CSR)으로 Search Engine Optimization(SEO)의 대응이 미흡하다.<br>\r\n그래서 <b>SEO를 대응하기 위해서 SSR 을 지원하는 Next.js를 사용</b>한다고 많은 포스트에서 작성하고 있다.\r\n\r\n## Next.js가 제공하는 기능들.\r\n\r\n### Pre-Rendering\r\n\r\n기본적으로 Next.js는 Static-Site Generate(SSG)와 Server Side Rendering(SSR)을 제공한다.<br>\r\n<br>\r\n두 가지 렌더링 호출 방식의 공통점은 <b>HTM"},{"title":"Google Sheets API","author":"Jay.J","date":"2023-07-20T00:00:00.000Z","categories":["javascript"],"tags":["javascript"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/javaScript.png","url":"/post/2023-07-20-googleSheetsAPI","con":"---\r\n\r\n<br>\r\n\r\n최근 회사 업무로 Google Sheets API를 사용하였다.<br>\r\n이전까지 데이터를 관리, 연동 개발은 DateBase(DB)만 생각하었는데,<br>\r\nDB구축을 하지 않고 간단하게 데이터를 저장하고 연동하여 활용할 수 있었다.<br>\r\n<br>\r\n개인적으로 간단하고 편하게 사용할 수 있었기에 정보를 공유하고 작성한다.\r\n\r\n<br>\r\n\r\n<hr>\r\n<br>\r\n\r\n## Google Sheets API\r\nGoogle Sheets API를 사용하기 위해서는 Google Sheets를 생성해줘야한다.<br>\r\n\r\n<br>\r\n\r\n### Google Sheets 생성하기.\r\n\r\n<br>\r\n\r\n1. Google 메인 화면에서 상단의 메뉴 > 드라이브를 눌러준다.\r\n\r\n<img src=\"/assets/img/javascript/google_sheet_creat.png\" alt=\"\">\r\n\r\n<br>\r\n\r\n2. 본인의 드라이브로 접속이 되었다면, 좌측 상단에 신규 "},{"title":"React_MUI","author":"Jay.J","date":"2023-07-10T00:00:00.000Z","categories":["javascript","ReactJs","MUI","css"],"tags":["javascript","ReactJs","MUI","css"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/mui.png","url":"/post/2023-07-10-React_MUI","con":"---\r\n\r\n<br>\r\n\r\n## MUI란\r\nMUI(Material UI)는 Material Design을 구현해놓은 라이브러리이다.<br>\r\n이 라이브러리를 이용하면 material 디자인 스타일이 적용된 UI를 매우 쉽게 구현할 수 있다. <br>\r\n<br>\r\n\r\n### Material Design이란?\r\n구글은 모바일과 데스크탑 그리고 그 외 다양한 디바이스들을 아우르는 하나의 일관된 디자인 가이드라인을 공개하였는데, 이것이 바로 <b>Material Design</b>이다.<br>\r\n<br>\r\n머티리얼 디자인은 질감이 느껴지는 표면 (tactile surfaces) 과 대담하고 선명한 그래픽 디자인 (bold graphic design), 그리고 아름답고 직관적인 사용자 경험을 위한 자연스러운 애니메이션을 특징으로 한다.\r\n\r\n<br>\r\n\r\n## MUI 설치하기\r\nMUI는 npm, yarn 등으로 설치할 수 있다.\r\n\r\n```js\r\n// npm\r\nnpm install @mui/"},{"title":"React란?","author":"Jay.J","date":"2023-03-07T00:00:00.000Z","categories":["javascript","ReactJs"],"tags":["javascript","ReactJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/react.png","url":"/post/2023-03-07-Reactjs","con":"---\r\n\r\n<br>\r\n\r\n## React.js 란 무엇인가?\r\nReact.js의 공식문서에서는 <b>'사용자 인터페이스를 만들기 위한 JavaScript 라이브러리'</b> 라고 설명하고 있다.<br>\r\n즉, 보여지는 화면을 만드는 자바스크립트 프레임워크 중의 하나이다.<br>\r\n\r\n> <a href=\"https://ko.legacy.reactjs.org/\" target=\"_blank\">React.js 공식사이트</a>\r\n\r\n<br>\r\n\r\n## 장점 및 특징\r\n1. Component 기반 구조\r\n2. Data Flow\r\n3. Virtual Dom\r\n4. JSX\r\n\r\n<Br>\r\n\r\n### Component 기반 구조\r\n\r\nVue.js 에서 한번 설명했던 구조이다.<br>\r\nDOM을 작은 단위로 쪼개어 개발하는 방식으로 유지보수와 재사용성이 높다.<br>\r\n<br>\r\n작은 단위로 쪼개져 있는 Dom 하나를 Component라 부르며, 독립된 Component들을 조립해 화면을 구성한다"},{"title":"느낌표 두개 연산자 - Double Exclamation Marks Operator","author":"Jay.J","date":"2022-12-12T00:00:00.000Z","categories":["javascript"],"tags":["javascript"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/javaScript.png","url":"/post/2022-12-12-doble_ExclamationMarks","con":"---\r\n\r\n<br>\r\n\r\n라이브러리를 사용하기 위하여 분석하다가 !! 연산자를 사용한 것을 본 적이 있다.<br>\r\n어떤 동작을 하는 연산자인지 검색해보고 알게된 내용을 정리하려고 한다.\r\n\r\n<br>\r\n\r\n## NOT 연산자인 (느낌표) and 느낌표 두개(!!) 연산자\r\n\r\n```js\r\nconsole.log(\"str\")      // \"str\"\r\nconsole.log(!(\"str\"))   //false\r\nconsole.log(!!(\"str\"))  //true\r\n\r\nconsole.log(\"\")         //\"\"\r\nconsole.log(!(\"\"))      //true\r\nconsole.log(!!(\"\"))     //false\r\n\r\nconsole.log(true)       //true\r\nconsole.log(!true)      //false\r\nconsole.log(!!true)     //true\r\n\r\nconsole.log(false)      //false\r\nconsol"},{"title":"클로져란 ?","author":"Jay.J","date":"2022-11-10T00:00:00.000Z","categories":["javascript"],"tags":["javascript"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/javaScript.png","url":"/post/2022-11-10-closure","con":"---\r\n\r\n<br>\r\n\r\n## 클로져란\r\n\r\n클로저는 함수와 함수가 선언된 어휘적 환경의 조합이다.<br>\r\n클로저를 이해하려면 자바스크립트가 어떻게 변수의 유효범위를 지정하는지(Lexical scoping)를 먼저 이해해야 한다.\r\n> MDN 출처\r\n\r\n<br>\r\n\r\n## 스코프\r\n\r\n자바스크립트의 스코프는 범위를 뜻한다.<br>\r\n\r\n```js\r\nfunction scope_a(){\r\n\tconst consoleData = 'a';\r\n\r\n\tfunction scope_b(){\r\n\t\tconst consoleData = 'b';\r\n\r\n\t\tconsole.log(consoleData); // b\r\n\t}\r\n\r\n\tscope_b();\r\n\tconsole.log(consoleData); // a\r\n}\r\n\r\nscope_a();\r\n```\r\n\r\n<br>\r\n\r\nscope_a 함수에서 consoleData 변수에 값 'a'를 넣었고,<br>\r\nscope_b 함수에서 consoleData 변수에 값 'b'를 "},{"title":"Web Component","author":"Jay.J","date":"2022-10-21T00:00:00.000Z","categories":["html","javascript"],"tags":["html","javascript"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/html.png","url":"/post/2022-10-21-WebComponent","con":"---\r\n\r\n<br>\r\n\r\n최근 어플리케이션 시장이 점점 커지고 복잡해지면서 컴포넌트 기반의 프레임워크들이 등장하였다.<br>\r\n복잡한 소프트웨어들을 간단한 부분들로 나눠서 개발하는 방식으로 대표적으로 React, Vue, Angluar등의 자바스크립트 프레임워크들이 있다<br>\r\n\r\n최근에는 자바스크립트의 프레임워크이 인기가 많아지면서 관심을 받고 있는데<br>\r\n그 기반인 웹 컴포넌트에 대해서 알아보려고 한다.\r\n\r\n## Web Component란\r\n\r\n컴포넌트(Component)란 기능을 다른 코드로부터 분리된 재사용이 가능한 독립적인 모듈을 뜻한다.<br>\r\n컴포넌트 기반 프로그래밍을 하면 마치 레고 블록처럼 이미 만들어진 컴포넌들을 조합하여 화면을 구성할 수 있다.<br>\r\n\r\n<img src=\"/assets/img/html/webComponent.jpg\" alt=\"\">\r\n\r\n<br>\r\n웹 컴포넌트는 이러한 컴포넌트 기반 프로그래밍을 웹에서도 적용할 수 있도록 W3C에서 새"},{"title":"async 와 await","author":"Jay.J","date":"2021-08-10T00:00:00.000Z","categories":["javascript"],"tags":["javascript"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/javaScript.png","url":"/post/2021-08-10-asyncAndawait","con":"---\r\n\r\n<br>\r\n\r\n## async 와 await 란\r\n\r\nasync는 asynchronous의 약자로 비동기 방식이다.\r\nasync는 예전부터 많이 봤었다.\r\n\r\n스크립트를 호출할 때도 사용했었으며,\r\n\r\n```js\r\n<script type=\"text/javascript\" src=\"common/js/script2.js\" async></script>\r\n```\r\n> 스크립트는 비동기적으로 호출한다.<br>\r\n> <a href=\"/blog/posts/%2Fpost%2F2018-03-29-Where_do_you_place_the_JavaScript\" target=\"_blank\">'Where do you place the JavaScript?' 포스터</a>\r\n\r\nAjax 또한 Ajax(<b>Asynchronous</b> JavaScript and XML)의 약자로, ajax 옵션중 async옵션이 존재한다.\r\n\r\n\r\n```js\r\n$.ajax({\r\n    ...\r\n    async:"},{"title":"ES6의 Map Filter Reduce 함수들","author":"Jay.J","date":"2021-07-15T00:00:00.000Z","categories":["javascript"],"tags":["javascript"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/javaScript.png","url":"/post/2021-07-15-MapFilterReduceInES6","con":"---\r\n\r\n<br>\r\n\r\n## ES6의 Map Filter Reduce 함수들\r\n\r\nmap, filter, reduce 함수 모두 ES6에서 추가된 함수로써, 배열(Array)에서 결과를 도출하고자 할 때 사용된다.<br>\r\n기존의 for문을 이용하여 loop 돌면서 결과를 도출했던 방식보다 유용하고 간결하게 사용할 수 있을 것으로 생각하며,<br>\r\n3개의 함수를 알아보고 정리하려고 한다.\r\n\r\n<br>\r\n\r\n## Map\r\n\r\nmap() 메서드는 배열 내의 모든 요소 각각에 대하여 주어진 함수를 호출한 결과를 모아 새로운 배열을 반환한다.\r\n\r\n### 구문\r\n\r\n```js\r\narr.map(callback(currentValue[, index[, array]])[, thisArg])\r\n```\r\n\r\n### 사용법\r\n\r\n```js\r\nconst numbers = [1, 2, 3];\r\nconst doubles = numbers.map( (num) => num * 2 );\r\n\r\nconsol"},{"title":"VanillaJs","author":"Jay.J","date":"2020-08-25T00:00:00.000Z","categories":["javascript"],"tags":["javascript","VanillaJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/javaScript.png","url":"/post/2020-08-25-VanillaJs","con":"---\r\n\r\n<br>\r\n\r\n## Vanilla JS란?\r\nVanilla JS(바닐라 자바스크립트)란 어떠한 프레임워크와 라이브러리가 적용되지 않은 날 것의 자바스크립트를 바닐라 자바스크립트라고 한다.\r\n\r\n<br>\r\n\r\n## 왜 Vanilla JS 사용하는 것인가\r\n개인적인 생각이지만 배보다 배꼽이 커지는 상황도 많았던 것 같다.<br>\r\njQuery라는 DOM을 컨트롤 하는데에 있어서 매우 뛰어난 라이브러리가 있다.<br>\r\n하지만 특정한 곳에서 한번만 사용할 것인데 그를 위해 jQuery를 사용한다면 효율적인 면에서 떨어진다.<br>\r\njQuery 또한 자바스크립트의 라이브러리이기 때문에 순수한 자바스크립트보다 속도면에서 성능이 떨어진다.<br>\r\n<br>\r\n또한 이전까지의 자바스크립트 버전은 DOM에 접근하려면 jQuery에 비해 길게 작성해야했기에 조금 더 편리한 jQuery를 개발하는 데 편하고 좋았다고 생각한다.<br>\r\n\r\n```js\r\n// class가 item 인 요소"},{"title":"자바스크립트 엄격모드?","author":"Jay.J","date":"2020-06-11T00:00:00.000Z","categories":["javascript"],"tags":["javascript"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/javaScript.png","url":"/post/2020-06-11-use_strict","con":"---\r\n\r\n<br>\r\n\r\n## 자바스크립트 엄격모드란 ?\r\n\r\nECMAScript 5 에서 소개되었다.<br>\r\n기본으로 우리 사용하는 자바스크립트는 <b>\"느슨한모드(sloppy mode)\"</b>라고 불리며<br>\r\n문법이나 살짝 벗어나는 오류 정도는 조용히 무시하고 작동되었다.<br>\r\n<b>\"엄격한 모드(strict mod)\"</b>를 사용하면 조금 더 디테일하게 문법이나 오류를 잡아낸다.\r\n\r\n<br>\r\n\r\n## 엄격모드를 사용하려면\r\n\r\n사용법은 간단하다. <br>\r\n엄격모드를 사용하기 위해서는 스크립트를 작성하기 전 최상단에 '\"use strict\";'를 작성해준다<br>\r\n\r\n```js\r\n\r\n'use strict';\r\n\r\nfunction A(){\r\n  ...\r\n}\r\n\r\nvar b = 'hi';\r\n\r\n```\r\n\r\n## 무엇이 다른가\r\n\r\n엄격모드를 설명하면서 조금 더 디테일하게 문법과 오류를 잡아낸다고 설명했다.<br>\r\n\r\n```js\r\n// 느슨한 모드\r\n\r\nb = "},{"title":"Javascript에서의 This","author":"Jay.J","date":"2020-04-15T00:00:00.000Z","categories":["javascript"],"tags":["javascript"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/javaScript.png","url":"/post/2020-04-15-javascriptThis","con":"---\r\n\r\n<br>\r\n\r\n## Javascript에서의 This\r\n\r\nthis가 무엇이냐라고 누군가 물어봤을 때 의미 자체에 순간 망설였던 적이 있었다.<br>\r\n그래서 this는 무엇이고 어떻게 동작하는 지에 대해 포스팅 하려고 한다.\r\n\r\n## This 무엇이냐 넌\r\nthis. 자바스크립트의 this는 호출한 객체가 저장되어있는 속성이다.\r\n\r\n```js\r\nconsole.log(this);  // window\r\n```\r\n\r\n기본적으로 this는 window 객체의 정보를 저장하고 있다.<br>\r\n기본적으로 사용하는 메서드들 또한 상단에의 window를 통해 호출하기 때문이다.\r\n\r\n```js\r\nwindow.console.log(this);  // window\r\n```\r\n> console에 찍힌 window 객체를 자세히보기를 열어서 찾으면 console를 찾을 수 있을 것이다.\r\n\r\nwindow객체의 console 객체의 log 메서드를 통하여 호출하였기에 this는 windo"},{"title":"Require.js 을 사용했던 프로젝트에 대한 회고","author":"Jay.J","date":"2019-02-10T00:00:00.000Z","categories":["javascript"],"tags":["javascript","AMD","require.js","Retrospect"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/javaScript.png","url":"/post/2019-02-10-requirejs_use","con":"---\r\n\r\n<br>\r\n\r\n## Require.js 을 사용했던 프로젝트에 대한 회고\r\n\r\n기존의 프로젝트를 진행할 때에는 필요한 기능을 전역 함수 파일에 추가하여 사용했다.<br>\r\n전역 파일에 기능을 추가하여 사용하다보니 기능이 늘어날 수록 코드는 복잡해져갔으며 <br>\r\n모든 페이지에서 불필요한 기능까지 전부 호출하는게 비효율적으로 느껴졌다.<br>\r\n<br>\r\n그렇기에 최근 알게 되었던 AMD/Require.js에 관심을 더욱 가지게 되었으며, <br>\r\n신규 프로젝트에 Require.js를 사용해보기 했다.<br>\r\n> <a href=\"/blog/posts/%2Fpost%2F2018-06-23-AMD_requirejs\">AMD / Require.js에 대한 포스팅</a>\r\n\r\n<br>\r\n\r\n### 프로젝트 초반\r\n\r\n디자인을 보고 퍼블리싱하며, 공통으로 쓰이는 기능과 특정 페이지에서 사용 되는 기능을 파악했다.<br>\r\n공통으로 쓰이는 기능들 가운데, 기존 전역 함수에 있었"},{"title":"AMD & require.js","author":"Jay.J","date":"2018-06-23T00:00:00.000Z","categories":["javascript"],"tags":["javascript","AMD","require.js"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/javaScript.png","url":"/post/2018-06-23-AMD_requirejs","con":"---\r\n\r\n<br>\r\n\r\n## AMD\r\n\r\nAMD(Asynchronous Module Definition)란 모듈을 정의하는 방법과 모듈이 필요할 때 비동기로 로딩하는 방법을 정의한 API 이다.\r\nAMD는 세 가지의 핵심 개념을 가지고 동작한다.\r\n<br>\r\n#### 1. 동적 로딩\r\n\r\n동적 로딩(Dynamic Loading, Lazy Loading)은 페이지 렌더링을 방해하지 않으면서 필요한 파일만 로딩할 수 있다.\r\n\r\n브라우저는 문서를 위에서 아래로 읽어내려오며, \\<script\\> 태그를 만나면 \\<script\\>의 HTTP 요청과 다운로드, 파싱(Parsing), 실행이 일어나는 동안 브라우저는 다른 동작을 하지 않는다.\r\n그로 인하여 페이지 렌더링은 느려지는데, 이를 최적화 하는 기법으로 \\<script\\> 태그를 \\<body\\> 태그의 마지막에 배치하는 방법이 있다.\r\n하지만 이 방법 또한 첫 렌더링과 첫 인터랙션에 필요하지 않은, 페이지에 필요한 모든 JavaSc"},{"title":"Javascript Call Stack and Event Loop","author":"Jay.J","date":"2018-05-11T00:00:00.000Z","categories":["javascript"],"tags":["javascript"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/javaScript.png","url":"/post/2018-05-11-Call_Stack_and_Event_Loop","con":"---\r\n\r\n<br>\r\n\r\n## Call Stack and Event Loop\r\n> 호출 스택 및 이벤트 루프\r\n\r\n<br>\r\n\r\n### 자바 스크립트 엔진\r\njavascript 를 해석하고 실행하는 인터프리터.\r\n> 인터프리터 : 프로그래밍 언어의 소스 코드를 바로 실행하는 컴퓨터 프로그램 또는 환경을 말한다.\r\n\r\n엔진에는 4가지로 구성되어있다.\r\n- [Heap](#heap)\r\n- [CallStack](#callstack)\r\n- [EventQueue](#eventqueue)\r\n- [EventLoop](#eventloop)\r\n\r\n<br>\r\n\r\n### Heap\r\n객체나 변수 값들이 들어가있는 영역으로 메모리의 할당이 일어나는 곳이다.\r\n\r\n<br>\r\n\r\n### CallStack\r\n\r\nCall Stack은 코드 실행에 따라 호출 스택(task)이 쌓이는 곳이다.<br>\r\n자바스크립트는 기본적으로 싱글 쓰레드 기반 언어이다.<br>\r\n따라서 코드 순서에 따라 호출 스택(task)이 쌓이"},{"title":"Javascript 실행 컨텍스트","author":"Jay.J","date":"2018-05-04T00:00:00.000Z","categories":["javascript"],"tags":["javascript"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/javaScript.png","url":"/post/2018-05-04-Execution_Context","con":"---\r\n\r\n<br>\r\n\r\n## Javascript 실행 컨텍스트\r\n\r\n<br>\r\n\r\n### 실행 컨테스트란\r\n\r\n자바스크립트가 실행될 때 생성되는 실행 단위를 실행 컨텍스트라고 부른다.  \r\n자바스크립트가 실행되면 함수들이 차곡차곡 <b>콜 스택(Call Stack)</b>이라 곳에 쌓이는데,  \r\n<b>실행 컨텍스트는 Call Stack에 쌓이는 하나하나의 실행 정보</b>이다.\r\n\r\n```js\r\n\r\nconsole.log('전역 스코프');\r\nfunction first(){\r\n  console.log('First Context');\r\n  second();\r\n}\r\nfunction second(){\r\n  console.log('Second Context');\r\n}\r\nfirst();\r\n\r\n// 컨텍스트 실행순서\r\n// 1. console.log('전역 스코프') 컨텍스트에 들어감  \r\n// 2. first함수가 컨텍스트에 들어감  \r\n// 3. second함수가 컨텍스트에 들어감\r\n/"},{"title":"How do you stop event propagation?","author":"Jay.J","date":"2018-04-09T00:00:00.000Z","categories":["javascript"],"tags":["javascript"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/javaScript.png","url":"/post/2018-04-09-stop_event_propagation","con":"---\r\n\r\n<br>\r\n\r\n## How do you stop event propagation?\r\n> 이벤트 전파를 어떻게 중지합니까?\r\n\r\n<br>\r\n\r\n### 이벤트 전파란?\r\n\r\n#### html\r\n```html\r\n<div class=\"boxDiv click01\">\r\n    <p>3</p>\r\n    <div class=\"boxDiv click02\">\r\n        <p>2</p>\r\n        <div class=\"boxDiv click03\">\r\n            <p>1</p>\r\n        </div>\r\n    </div>\r\n</div>\r\n<p class=\"result\"></p>\r\n```\r\n#### css\r\n```css\r\n.boxDiv{border:1px solid #000;padding:20px}\r\n.click01{width:300px;margin:0 50px;background:#aaa}\r\n.click02{background:#ddd}\r\n.click03{backg"},{"title":"Where do you place the JavaScript?","author":"Jay.J","date":"2018-03-29T00:00:00.000Z","categories":["javascript"],"tags":["javascript"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/javaScript.png","url":"/post/2018-03-29-Where_do_you_place_the_JavaScript","con":"---\r\n\r\n<br>\r\n\r\n## Where do you place the JavaScript?\r\n> JavaScript는 어디에 두어야합니까?\r\n\r\n<br>\r\n\r\n### 1. Head, Body\r\nhead Tag 섹션에 삽입하거나 body Tag 섹션의 시작 부분에 놓는 방법은 안좋다.  \r\n해당 부분에 위치시킬 경우 문서는 페이지 로드시  \r\n페이지를 읽다가 script Tag를 만날 경우 페이지의 분석을 멈추고  \r\n스크립트를 로드한 후 페이지를 읽기 때문에 성능면에서 안좋다.  \r\n<br>\r\n\r\n#### 브라우저가 웹 사이트를 로드 할 때 일어나는 일\r\n1. 문서 가져 온다 (예 : index.html, index.asp, main.php ...등)\r\n2. HTML 구문 분석한다.\r\n3. 파서는 문서를 위에서 부터 아래로 읽는다.  \r\n    중간에 외부 스크립트 파일을 참조하는 script Tag를 발견한다.\r\n4. 브라우저가 스크립트 파일을 확인하고 요청한다.  \r\n    "}]}