{"postlist":[{"title":"느낌표 두개 연산자 - Double Exclamation Marks Operator","author":"Jay.J","date":"2022-12-12T00:00:00.000Z","categories":["javascript"],"tags":["javascript"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/javaScript.png","url":"/post/2022-12-12-doble_ExclamationMarks","con":"---\n\n<br>\n\n라이브러리를 사용하기 위하여 분석하다가 !! 연산자를 사용한 것을 본 적이 있다.<br>\n어떤 동작을 하는 연산자인지 검색해보고 알게된 내용을 정리하려고 한다.\n\n<br>\n\n## NOT 연산자인 (느낌표) and 느낌표 두개(!!) 연산자\n\n```js\nconsole.log(\"str\")      // \"str\"\nconsole.log(!(\"str\"))   //false\nconsole.log(!!(\"str\"))  //true\n\nconsole.log(\"\")         //\"\"\nconsole.log(!(\"\"))      //true\nconsole.log(!!(\"\"))     //false\n\nconsole.log(true)       //true\nconsole.log(!true)      //false\nconsole.log(!!true)     //true\n\nconsole.log(false)      //false\nconsole.log(!false)     //true\n"},{"title":"클로져란 ?","author":"Jay.J","date":"2022-11-10T00:00:00.000Z","categories":["javascript"],"tags":["javascript"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/javaScript.png","url":"/post/2022-11-10-closure","con":"---\n\n<br>\n\n## 클로져란\n\n클로저는 함수와 함수가 선언된 어휘적 환경의 조합이다.<br>\n클로저를 이해하려면 자바스크립트가 어떻게 변수의 유효범위를 지정하는지(Lexical scoping)를 먼저 이해해야 한다.\n> MDN 출처\n\n<br>\n\n## 스코프\n\n자바스크립트의 스코프는 범위를 뜻한다.<br>\n\n```js\nfunction scope_a(){\n\tconst consoleData = 'a';\n\n\tfunction scope_b(){\n\t\tconst consoleData = 'b';\n\n\t\tconsole.log(consoleData); // b\n\t}\n\n\tscope_b();\n\tconsole.log(consoleData); // a\n}\n\nscope_a();\n```\n\n<br>\n\nscope_a 함수에서 consoleData 변수에 값 'a'를 넣었고,<br>\nscope_b 함수에서 consoleData 변수에 값 'b'를 넣었다.<br>\n<br>\nscope_b 함수를 실행하면서 cons"},{"title":"Web Component","author":"Jay.J","date":"2022-10-21T00:00:00.000Z","categories":["html","javascript"],"tags":["html","javascript"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/html.png","url":"/post/2022-10-21-WebComponent","con":"---\n\n<br>\n\n최근 어플리케이션 시장이 점점 커지고 복잡해지면서 컴포넌트 기반의 프레임워크들이 등장하였다.<br>\n복잡한 소프트웨어들을 간단한 부분들로 나눠서 개발하는 방식으로 대표적으로 React, Vue, Angluar등의 자바스크립트 프레임워크들이 있다<br>\n\n최근에는 자바스크립트의 프레임워크이 인기가 많아지면서 관심을 받고 있는데<br>\n그 기반인 웹 컴포넌트에 대해서 알아보려고 한다.\n\n## Web Component란\n\n컴포넌트(Component)란 기능을 다른 코드로부터 분리된 재사용이 가능한 독립적인 모듈을 뜻한다.<br>\n컴포넌트 기반 프로그래밍을 하면 마치 레고 블록처럼 이미 만들어진 컴포넌들을 조합하여 화면을 구성할 수 있다.<br>\n\n<img src=\"/assets/img/html/webComponent.jpg\" alt=\"\">\n\n<br>\n웹 컴포넌트는 이러한 컴포넌트 기반 프로그래밍을 웹에서도 적용할 수 있도록 W3C에서 새로 정한 규격이다.<br>\n\n<b"},{"title":"async 와 await","author":"Jay.J","date":"2021-08-10T00:00:00.000Z","categories":["javascript"],"tags":["javascript"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/javaScript.png","url":"/post/2021-08-10-asyncAndawait","con":"---\n\n<br>\n\n## async 와 await 란\n\nasync는 asynchronous의 약자로 비동기 방식이다.\nasync는 예전부터 많이 봤었다.\n\n스크립트를 호출할 때도 사용했었으며,\n\n```js\n<script type=\"text/javascript\" src=\"common/js/script2.js\" async></script>\n```\n> 스크립트는 비동기적으로 호출한다.<br>\n> <a href=\"/blog/posts/%2Fpost%2F2018-03-29-Where_do_you_place_the_JavaScript\" target=\"_blank\">'Where do you place the JavaScript?' 포스터</a>\n\nAjax 또한 Ajax(<b>Asynchronous</b> JavaScript and XML)의 약자로, ajax 옵션중 async옵션이 존재한다.\n\n\n```js\n$.ajax({\n    ...\n    async: false,\n    success: fu"},{"title":"ES6의 Map Filter Reduce 함수들","author":"Jay.J","date":"2021-07-15T00:00:00.000Z","categories":["javascript"],"tags":["javascript"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/javaScript.png","url":"/post/2021-07-15-MapFilterReduceInES6","con":"---\n\n<br>\n\n## ES6의 Map Filter Reduce 함수들\n\nmap, filter, reduce 함수 모두 ES6에서 추가된 함수로써, 배열(Array)에서 결과를 도출하고자 할 때 사용된다.<br>\n기존의 for문을 이용하여 loop 돌면서 결과를 도출했던 방식보다 유용하고 간결하게 사용할 수 있을 것으로 생각하며,<br>\n3개의 함수를 알아보고 정리하려고 한다.\n\n<br>\n\n## Map\n\nmap() 메서드는 배열 내의 모든 요소 각각에 대하여 주어진 함수를 호출한 결과를 모아 새로운 배열을 반환한다.\n\n### 구문\n\n```js\narr.map(callback(currentValue[, index[, array]])[, thisArg])\n```\n\n### 사용법\n\n```js\nconst numbers = [1, 2, 3];\nconst doubles = numbers.map( (num) => num * 2 );\n\nconsole.log(doubles);\n```\n> 결과값 : "},{"title":"VanillaJs","author":"Jay.J","date":"2020-08-25T00:00:00.000Z","categories":["javascript"],"tags":["javascript","VanillaJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/javaScript.png","url":"/post/2020-08-25-VanillaJs","con":"---\n\n<br>\n\n## Vanilla JS란?\nVanilla JS(바닐라 자바스크립트)란 어떠한 프레임워크와 라이브러리가 적용되지 않은 날 것의 자바스크립트를 바닐라 자바스크립트라고 한다.\n\n<br>\n\n## 왜 Vanilla JS 사용하는 것인가\n개인적인 생각이지만 배보다 배꼽이 커지는 상황도 많았던 것 같다.<br>\njQuery라는 DOM을 컨트롤 하는데에 있어서 매우 뛰어난 라이브러리가 있다.<br>\n하지만 특정한 곳에서 한번만 사용할 것인데 그를 위해 jQuery를 사용한다면 효율적인 면에서 떨어진다.<br>\njQuery 또한 자바스크립트의 라이브러리이기 때문에 순수한 자바스크립트보다 속도면에서 성능이 떨어진다.<br>\n<br>\n또한 이전까지의 자바스크립트 버전은 DOM에 접근하려면 jQuery에 비해 길게 작성해야했기에 조금 더 편리한 jQuery를 개발하는 데 편하고 좋았다고 생각한다.<br>\n\n```js\n// class가 item 인 요소에 이벤트 바인딩\n\n// java"},{"title":"자바스크립트 엄격모드?","author":"Jay.J","date":"2020-06-11T00:00:00.000Z","categories":["javascript"],"tags":["javascript"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/javaScript.png","url":"/post/2020-06-11-use_strict","con":"---\n\n<br>\n\n## 자바스크립트 엄격모드란 ?\n\nECMAScript 5 에서 소개되었다.<br>\n기본으로 우리 사용하는 자바스크립트는 <b>\"느슨한모드(sloppy mode)\"</b>라고 불리며<br>\n문법이나 살짝 벗어나는 오류 정도는 조용히 무시하고 작동되었다.<br>\n<b>\"엄격한 모드(strict mod)\"</b>를 사용하면 조금 더 디테일하게 문법이나 오류를 잡아낸다.\n\n<br>\n\n## 엄격모드를 사용하려면\n\n사용법은 간단하다. <br>\n엄격모드를 사용하기 위해서는 스크립트를 작성하기 전 최상단에 '\"use strict\";'를 작성해준다<br>\n\n```js\n\n'use strict';\n\nfunction A(){\n  ...\n}\n\nvar b = 'hi';\n\n```\n\n## 무엇이 다른가\n\n엄격모드를 설명하면서 조금 더 디테일하게 문법과 오류를 잡아낸다고 설명했다.<br>\n\n```js\n// 느슨한 모드\n\nb = 'hi';\nvar undefined = 5;\nfunction sum"},{"title":"Javascript에서의 This","author":"Jay.J","date":"2020-04-15T00:00:00.000Z","categories":["javascript"],"tags":["javascript"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/javaScript.png","url":"/post/2020-04-15-javascriptThis","con":"---\n\n<br>\n\n## Javascript에서의 This\n\nthis가 무엇이냐라고 누군가 물어봤을 때 의미 자체에 순간 망설였던 적이 있었다.<br>\n그래서 this는 무엇이고 어떻게 동작하는 지에 대해 포스팅 하려고 한다.\n\n## This 무엇이냐 넌\nthis. 자바스크립트의 this는 호출한 객체가 저장되어있는 속성이다.\n\n```js\nconsole.log(this);  // window\n```\n\n기본적으로 this는 window 객체의 정보를 저장하고 있다.<br>\n기본적으로 사용하는 메서드들 또한 상단에의 window를 통해 호출하기 때문이다.\n\n```js\nwindow.console.log(this);  // window\n```\n> console에 찍힌 window 객체를 자세히보기를 열어서 찾으면 console를 찾을 수 있을 것이다.\n\nwindow객체의 console 객체의 log 메서드를 통하여 호출하였기에 this는 window의 정보를 저장하고 있다.\n\n<br>\n\n#"},{"title":"Require.js 을 사용했던 프로젝트에 대한 회고","author":"Jay.J","date":"2019-02-10T00:00:00.000Z","categories":["javascript"],"tags":["javascript","AMD","require.js","Retrospect"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/javaScript.png","url":"/post/2019-02-10-requirejs_use","con":"---\n\n<br>\n\n## Require.js 을 사용했던 프로젝트에 대한 회고\n\n기존의 프로젝트를 진행할 때에는 필요한 기능을 전역 함수 파일에 추가하여 사용했다.<br>\n전역 파일에 기능을 추가하여 사용하다보니 기능이 늘어날 수록 코드는 복잡해져갔으며 <br>\n모든 페이지에서 불필요한 기능까지 전부 호출하는게 비효율적으로 느껴졌다.<br>\n<br>\n그렇기에 최근 알게 되었던 AMD/Require.js에 관심을 더욱 가지게 되었으며, <br>\n신규 프로젝트에 Require.js를 사용해보기 했다.<br>\n> <a href=\"/blog/posts/%2Fpost%2F2018-06-23-AMD_requirejs\">AMD / Require.js에 대한 포스팅</a>\n\n<br>\n\n### 프로젝트 초반\n\n디자인을 보고 퍼블리싱하며, 공통으로 쓰이는 기능과 특정 페이지에서 사용 되는 기능을 파악했다.<br>\n공통으로 쓰이는 기능들 가운데, 기존 전역 함수에 있었던 기능들은 분리하여 모듈화 시키며"},{"title":"AMD & require.js","author":"Jay.J","date":"2018-06-23T00:00:00.000Z","categories":["javascript"],"tags":["javascript","AMD","require.js"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/javaScript.png","url":"/post/2018-06-23-AMD_requirejs","con":"---\n\n<br>\n\n## AMD\n\nAMD(Asynchronous Module Definition)란 모듈을 정의하는 방법과 모듈이 필요할 때 비동기로 로딩하는 방법을 정의한 API 이다.\nAMD는 세 가지의 핵심 개념을 가지고 동작한다.\n<br>\n#### 1. 동적 로딩\n\n동적 로딩(Dynamic Loading, Lazy Loading)은 페이지 렌더링을 방해하지 않으면서 필요한 파일만 로딩할 수 있다.\n\n브라우저는 문서를 위에서 아래로 읽어내려오며, \\<script\\> 태그를 만나면 \\<script\\>의 HTTP 요청과 다운로드, 파싱(Parsing), 실행이 일어나는 동안 브라우저는 다른 동작을 하지 않는다.\n그로 인하여 페이지 렌더링은 느려지는데, 이를 최적화 하는 기법으로 \\<script\\> 태그를 \\<body\\> 태그의 마지막에 배치하는 방법이 있다.\n하지만 이 방법 또한 첫 렌더링과 첫 인터랙션에 필요하지 않은, 페이지에 필요한 모든 JavaScript를 로딩하기 때문에 "},{"title":"Javascript Call Stack and Event Loop","author":"Jay.J","date":"2018-05-11T00:00:00.000Z","categories":["javascript"],"tags":["javascript"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/javaScript.png","url":"/post/2018-05-11-Call_Stack_and_Event_Loop","con":"---\n\n<br>\n\n## Call Stack and Event Loop\n> 호출 스택 및 이벤트 루프\n\n<br>\n\n### 자바 스크립트 엔진\njavascript 를 해석하고 실행하는 인터프리터.\n> 인터프리터 : 프로그래밍 언어의 소스 코드를 바로 실행하는 컴퓨터 프로그램 또는 환경을 말한다.\n\n엔진에는 4가지로 구성되어있다.\n- [Heap](#heap)\n- [CallStack](#callstack)\n- [EventQueue](#eventqueue)\n- [EventLoop](#eventloop)\n\n<br>\n\n### Heap\n객체나 변수 값들이 들어가있는 영역으로 메모리의 할당이 일어나는 곳이다.\n\n<br>\n\n### CallStack\n\nCall Stack은 코드 실행에 따라 호출 스택(task)이 쌓이는 곳이다.<br>\n자바스크립트는 기본적으로 싱글 쓰레드 기반 언어이다.<br>\n따라서 코드 순서에 따라 호출 스택(task)이 쌓이면 작업 시 그 순서에 맞게 한번에 하나씩 호출하여 처"},{"title":"Javascript 실행 컨텍스트","author":"Jay.J","date":"2018-05-04T00:00:00.000Z","categories":["javascript"],"tags":["javascript"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/javaScript.png","url":"/post/2018-05-04-Execution_Context","con":"---\r\n\r\n<br>\r\n\r\n## Javascript 실행 컨텍스트\r\n\r\n<br>\r\n\r\n### 실행 컨테스트란\r\n\r\n자바스크립트가 실행될 때 생성되는 실행 단위를 실행 컨텍스트라고 부른다.  \r\n자바스크립트가 실행되면 함수들이 차곡차곡 <b>콜 스택(Call Stack)</b>이라 곳에 쌓이는데,  \r\n<b>실행 컨텍스트는 Call Stack에 쌓이는 하나하나의 실행 정보</b>이다.\r\n\r\n```js\r\n\r\nconsole.log('전역 스코프');\r\nfunction first(){\r\n  console.log('First Context');\r\n  second();\r\n}\r\nfunction second(){\r\n  console.log('Second Context');\r\n}\r\nfirst();\r\n\r\n// 컨텍스트 실행순서\r\n// 1. console.log('전역 스코프') 컨텍스트에 들어감  \r\n// 2. first함수가 컨텍스트에 들어감  \r\n// 3. second함수가 컨텍스트에 들어감\r\n/"},{"title":"How do you stop event propagation?","author":"Jay.J","date":"2018-04-09T00:00:00.000Z","categories":["javascript"],"tags":["javascript"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/javaScript.png","url":"/post/2018-04-09-stop_event_propagation","con":"---\n\n<br>\n\n## How do you stop event propagation?\n> 이벤트 전파를 어떻게 중지합니까?\n\n<br>\n\n### 이벤트 전파란?\n\n#### html\n```html\n<div class=\"boxDiv click01\">\n    <p>3</p>\n    <div class=\"boxDiv click02\">\n        <p>2</p>\n        <div class=\"boxDiv click03\">\n            <p>1</p>\n        </div>\n    </div>\n</div>\n<p class=\"result\"></p>\n```\n#### css\n```css\n.boxDiv{border:1px solid #000;padding:20px}\n.click01{width:300px;margin:0 50px;background:#aaa}\n.click02{background:#ddd}\n.click03{background:#fff}\n```\n#### js\n```js"},{"title":"Where do you place the JavaScript?","author":"Jay.J","date":"2018-03-29T00:00:00.000Z","categories":["javascript"],"tags":["javascript"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/javaScript.png","url":"/post/2018-03-29-Where_do_you_place_the_JavaScript","con":"---\r\n\r\n<br>\r\n\r\n## Where do you place the JavaScript?\r\n> JavaScript는 어디에 두어야합니까?\r\n\r\n<br>\r\n\r\n### 1. Head, Body\r\nhead Tag 섹션에 삽입하거나 body Tag 섹션의 시작 부분에 놓는 방법은 안좋다.  \r\n해당 부분에 위치시킬 경우 문서는 페이지 로드시  \r\n페이지를 읽다가 script Tag를 만날 경우 페이지의 분석을 멈추고  \r\n스크립트를 로드한 후 페이지를 읽기 때문에 성능면에서 안좋다.  \r\n<br>\r\n\r\n#### 브라우저가 웹 사이트를 로드 할 때 일어나는 일\r\n1. 문서 가져 온다 (예 : index.html, index.asp, main.php ...등)\r\n2. HTML 구문 분석한다.\r\n3. 파서는 문서를 위에서 부터 아래로 읽는다.  \r\n    중간에 외부 스크립트 파일을 참조하는 script Tag를 발견한다.\r\n4. 브라우저가 스크립트 파일을 확인하고 요청한다.  \r\n    "}]}