{"postlist":[{"title":"느낌표 두개 연산자 - Double Exclamation Marks Operator","author":"Jay.J","date":"2022-12-12T00:00:00.000Z","categories":["javascript"],"tags":["javascript"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/javaScript.png","url":"/post/2022-12-12-doble_ExclamationMarks","con":"---\n\n<br>\n\n라이브러리를 사용하기 위하여 분석하다가 !! 연산자를 사용한 것을 본 적이 있다.<br>\n어떤 동작을 하는 연산자인지 검색해보고 알게된 내용을 정리하려고 한다.\n\n<br>\n\n## NOT 연산자인 (느낌표) and 느낌표 두개(!!) 연산자\n\n```js\nconsole.log(\"str\")      // \"str\"\nconsole.log(!(\"str\"))   //false\nconsole.log(!!(\"str\"))  //true\n\nconsole.log(\"\")         //\"\"\nconsole.log(!(\"\"))      //true\nconsole.log(!!(\"\"))     //false\n\nconsole.log(true)       //true\nconsole.log(!true)      //false\nconsole.log(!!true)     //true\n\nconsole.log(false)      //false\nconsole.log(!false)     //true\n"},{"title":"클로져란 ?","author":"Jay.J","date":"2022-11-10T00:00:00.000Z","categories":["javascript"],"tags":["javascript"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/javaScript.png","url":"/post/2022-11-10-closure","con":"---\n\n<br>\n\n## 클로져란\n\n클로저는 함수와 함수가 선언된 어휘적 환경의 조합이다.<br>\n클로저를 이해하려면 자바스크립트가 어떻게 변수의 유효범위를 지정하는지(Lexical scoping)를 먼저 이해해야 한다.\n> MDN 출처\n\n<br>\n\n## 스코프\n\n자바스크립트의 스코프는 범위를 뜻한다.<br>\n\n```js\nfunction scope_a(){\n\tconst consoleData = 'a';\n\n\tfunction scope_b(){\n\t\tconst consoleData = 'b';\n\n\t\tconsole.log(consoleData); // b\n\t}\n\n\tscope_b();\n\tconsole.log(consoleData); // a\n}\n\nscope_a();\n```\n\n<br>\n\nscope_a 함수에서 consoleData 변수에 값 'a'를 넣었고,<br>\nscope_b 함수에서 consoleData 변수에 값 'b'를 넣었다.<br>\n<br>\nscope_b 함수를 실행하면서 cons"},{"title":"Web Component","author":"Jay.J","date":"2022-10-21T00:00:00.000Z","categories":["html","javascript"],"tags":["html","javascript"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/html.png","url":"/post/2022-10-21-WebComponent","con":"---\n\n<br>\n\n최근 어플리케이션 시장이 점점 커지고 복잡해지면서 컴포넌트 기반의 프레임워크들이 등장하였다.<br>\n복잡한 소프트웨어들을 간단한 부분들로 나눠서 개발하는 방식으로 대표적으로 React, Vue, Angluar등의 자바스크립트 프레임워크들이 있다<br>\n\n최근에는 자바스크립트의 프레임워크이 인기가 많아지면서 관심을 받고 있는데<br>\n그 기반인 웹 컴포넌트에 대해서 알아보려고 한다.\n\n## Web Component란\n\n컴포넌트(Component)란 기능을 다른 코드로부터 분리된 재사용이 가능한 독립적인 모듈을 뜻한다.<br>\n컴포넌트 기반 프로그래밍을 하면 마치 레고 블록처럼 이미 만들어진 컴포넌들을 조합하여 화면을 구성할 수 있다.<br>\n\n<img src=\"/assets/img/html/webComponent.jpg\" alt=\"\">\n\n<br>\n웹 컴포넌트는 이러한 컴포넌트 기반 프로그래밍을 웹에서도 적용할 수 있도록 W3C에서 새로 정한 규격이다.<br>\n\n<b"},{"title":"Vue에서 사용하는 SEO","author":"Jay.J","date":"2022-09-04T00:00:00.000Z","categories":["html","VueJs"],"tags":["html","vue.js"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/vuejs.png","url":"/post/2022-09-04-SeoUsedInVue","con":"---\n\n<br>\n\n최근 들어 SPA로 구현된 사이트가 증가하고 있다.<br>\n하지만 SPA 검색엔진에 잘 노출이 되지 않아 사이트에 많은 사람들이 방문하지 못하는 문제들이 생기고 있다.<br>\nSPA에서의 SEO는 어떻게 해결하는 지 포스팅하려고 한다.\n\n## MPA와 SPA의 차이\n\nSEO를 어떻게 해결하는 방법이 있는 지 알아보기 전에, MPA와 SPA에 대해서 알아야한다.\n\n## MPA\n\nMPA(Multiple Page Application)는 여러 개(Multiple)의 Page로 구성된 Application이다.<br>\n전통적인 방식으로 페이지를 요청할 때마다 정적 리소스가 다운로드된다. <b>매번 전체 페이지가 다시 렌더링</b> 된다.<br>\nMPA를 SSR(Server Side Rendering) 방식으로 렌더링한다고 말한다.<br>\n<br>\n\n<img src=\"/assets/img/html/MPA.webp\" alt=\"\">\n> MPA의 SSR 방식\n\n<br>\n\n<im"},{"title":"'적응형 웹'과 '반응형 웹'","author":"Jay.J","date":"2022-08-16T00:00:00.000Z","categories":["html"],"tags":["html"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/html.png","url":"/post/2022-08-16-AdaptiveWebAndResponsiveWeb","con":"---\n\n<br>\n\n## '적응형 웹'과 '반응형 웹' 이란?\n\n1. <b>적응형 웹 : </b> 각각의 디바이스 별로 독립적인 템플릿(Templete)으로 랜딩되는 웹.\n2. <b>반응형 웹 : </b> 하나의 템플릿(Templete)로 모바일 , 태블릿, 데스크탑 모든 기기에 대응할 수 있는 웹.\n\n<br>\n<hr>\n<br>\n\n## 적응형 웹 ( Adaptive Web )\n\n<b>'각각의 디바이스 별로 독립적인 템플릿(Templete)으로 랜딩되는 웹'</b>\n<br>\n각각의 디바이스별(Pc, Mobile)로 템플릿을 제작해야하며, 사용자가 url로 접속시 어떤 디바이스로 접속했는지 파악하여 디바이스별로 랜딩시켜준다.<br>\n예를들어 PC로 접속하면 PC URL로 랜딩되고, Mobile로 접속시 Mobile URL을 랜딩시켜준다.\n\n<img src=\"/assets/img/html/Adaptive.gif\" alt=\"\" style=\"max-width:550px\">\n\n<br>\n<hr>"},{"title":"브라우저의 동작원리","author":"Jay.J","date":"2022-07-14T00:00:00.000Z","categories":["html"],"tags":["html"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/html.png","url":"/post/2022-07-14-DOMRendering","con":"---\n\n<br>\n\n최근 HTML 파일은 어떻게 브라우저에 그려지는지 질문을 받은 적이 있다.<br>\nVue를 공부하면서 브라우저의 동작원리에 대해서 잠깐 다룬적이 있었으나,<br>\n정확히 알고 있지 않아서 답변을 할 수 없었고 이번 기회에 브라우저 렌더링 과정에 대해서 공부하고 정리해보려고 한다.\n\n## 브라우저 렌더링 동작 과정\n\n주소창에 url을 입력하고 접속하였을 때 브라우저는 해당 페이지에 대한 리소스를 서버에 요청한다.<br>\n그 이후 브라우저의 렌더링 동작 과정은 5가지로 나눌 수 있다.\n\n1. Parsing\n2. Render Tree\n3. Layout\n4. Paint\n5. Composite\n\n<br>\n\n<img src=\"/assets/img/vue/webkitflow.png\" alt=\"\">\n> 브라우저의 동작 순서\n\n### 1. Parsing\n\n서버에서 받아온 리소스(HTML, CSS)의 문자는 브라우저가 바로 인식하지 못한다.<br>\n그렇기에 문자를 해석하는 과정이 "},{"title":"Box Model","author":"Jay.J","date":"2022-05-24T00:00:00.000Z","categories":["html","css"],"tags":["html","css"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/html.png","url":"/post/2022-05-24-BoxModel","con":"---\n\n<br>\n\n## Box Model이란?\n\n모든 HTML 요소는 박스(box) 모양으로 구성되며, 이것을 박스 모델(box model)이라고 부른다.\n박스 모델은 HTML 요소를 패딩(padding), 테두리(border), 마진(margin), 그리고 내용(content)으로 구분한다.\n\n<br>\n\n## 웹 브라우저에서의 Box Model은?\n\n웹 브라우저에서의 Box Model은 content-box 와 border-box 기준이 있다.\ncontent-box는 콘텐츠 영역을 기준으로 크기를 정하며 border-box는 테두리 영역을 기준으로 크기를 정한다.\nCSS의 속성을 통하여 Box Model의 기준을 정할 수 있다.\n\n<br>\n\n## CSS 문법\n\n```css\nbox-sizing: content-box | border-box | initial | inherit\n```\n<br>\n\n- content-box : 콘텐트 영역을 기준으로 크기를 정한다\n- border-box "},{"title":"DOCTYPE 이란?","author":"Jay.J","date":"2022-05-03T00:00:00.000Z","categories":["html"],"tags":["html"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/html.png","url":"/post/2022-05-06-DOCTYPE","con":"---\n\n<br>\n\n## DOCTYPE 란?\n웹 문서에서 DTD(문서 유형 정의)를 통해서 현재 문서가 어떤 버전으로 기술되었는지 브라우저에 전달하는데 이것을 DOCTYPE 선언이라고 한다.<br>\nDTD(Document Type Definition)는 XHTML, HTML, HTML5 세 가지 유형이 있으며, 선언된 문서 형식에 따라 마크업 속성을 처리하는 기준이 정해지고, 유효성 검사에 활용된다.\n\n<br>\n\n## DOCTYPE 선언의 목적\n\n웹 브라우저는 두 가지 렌더링 모드를 가지고 있는데 쿼크모드(Quirks mode)와 표준모드(Standard mode)이다.<br>\n브라우저가 출력하고자 하는 문서가 최신이라면 표준모드로 렌더링하며, 오래된 문서라면 쿼크 모드로 렌더링 하게 된다.<br>\n<br>\n이 과정에서 어떤 유형의 문서인지 정의해주는 것이 DOCTYPE 선언이다.\nDOCTYPE을 생략할 경우, 브라우저마다 상이하게 보여지거나(크로스 브라우징 오류) 버전에 따라 태그"},{"title":"CSS의 BEM을 사용해보자","author":"Jay.J","date":"2022-04-12T00:00:00.000Z","categories":["css"],"tags":["css"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/css.png","url":"/post/2022-04-12-BEM","con":"---\n\n<br>\n\n## BEM이란?\n\nBEM은 CSS 네이밍 방법론 중 하나이다.<br>\nHTML의 요소를 <b>Block</b>, <b>Element</b>, <b>Modifier</b> 세가지로 구분하여 클래스명을 작명하는 방법이다.\n\n<br>\n\n## BEM의 장점\n\n- 목적과 기능을 직관적으로 알 수 있다.\n- 재사용성이 높다.\n- CSS만으로 구조를 알 수 있다.\n\n<br>\n\n## Block\n\n### 의미\nBlock 은 단독으로 사용할 수 있는 <b>독립적인 요소</b>이다.<br>\n<b>재사용성이 가능</b>하고 높은 요소이다.<br>\n재사용을 위해서 Block 요소에는 <b>Padding과 Margin 속성을 적용하지 않는다.</b>\n\n### HTML 구조\n\n```\n*** HTML ***\n\n<header>\n    <div>\n        Logo\n    </div>\n\n    <nav>\n        Navigater\n    </nav>\n</header>\n```\n> 위 소"},{"title":"CSS Flex","author":"Jay.J","date":"2022-03-02T00:00:00.000Z","categories":["css"],"tags":["css"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/css.png","url":"/post/2022-03-02-flex","con":"---\n\n<br>\n\nflex 는 레이아웃 구조를 잡을 수 있는 CSS 속성 중 하나이다.<br>\n컨테이너가 차지하는 공간에 맞춰서 아이템들이 유연하게 조절되기 때문에 레이아웃을 보다 쉽게 구현할 수 있다.<br>\n<br>\nInternet Explorer(이하 IE) 점유율이 높고 하위 버전까지 맞춰야 할 예전에는 하위 버전까지 지원하지 않아 잘 사용되지않았지만,<br> 현재 IE의 점유율이 낮아지면서 너무 낮은 버전의 IE 브라우저는 안맞추는 추세로 프로젝트가 진행되면서 많이 사용되었다.\n\n\n## 구성\n\n<img src=\"/assets/img/css/flex_container.png\" alt=\"\">\n\nflex는 부모 요소인 flex container과 자식 요소인 flex item으로 구성되어 있다.\n\n```\n*** HTML *** \n<div class=\"flex_container\">\n    <div class=\"flex_item\">Item 1</div>\n    <div class="},{"title":"Git Fetch","author":"Jay.J","date":"2022-01-23T00:00:00.000Z","categories":["Git"],"tags":["Git"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/git.png","url":"/post/2022-01-23-GitFetch","con":"---\n\n<br>\n\n이전 Git 도입에 대한 포스팅을 작성하고 Git을 사용하면서 commit, pull, push, merge 등의 자주 사용하는 명령어만 포스팅하고 사용하였다.<br>\n기존에 설명한 명령어 외에 Fetch에 대해서 포스팅하려고 한다.\n\n## Fetch\n\n원격 저장소에 저장 되어있는 소스를 로컬 저장소로 가져오는 명령어이다.<br>\n<br>\n원격 저장소에서 소스를 가져오는 명령어는 Pull도 있다.<br>\nPull과 Fetch의 차이는 병합(Merge)에 있다.\n\n- <b>Pull : </b>원격 저장소에서 소스를 가져와서 자동으로 병합한다.\n- <b>Fetch : </b>원격 저장소에서 소스를 가져오기만 한다.\n\n<br>\n\nPull의 경우 자동으로 병합해주기 때문에 어떤 내용이 병합되었는 지 스스로 찾아서 확인해야한다.<br>\nFetch의 경우 소스만 가져오기 때문에 변경된 내용을 한번에 확인할 수 있다.<br>\n하지만 직접 병합하는 과정을 거쳐야한다.<br>\n<"},{"title":"Git 도입과 브랜치전략","author":"Jay.J","date":"2022-01-12T00:00:00.000Z","categories":["Git"],"tags":["Git"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/git.png","url":"/post/2022-01-12-GitIntroduction","con":"---\n\n<br>\n\n## Git 도입과 브랜치전략\n\n사내에 소스 형상관리를 하고 있지않아, 소스가 날아가거나 백업파일을 만들어서 불필요한 용량을 차지한다거나 크고 작은 일들이 지속적으로 발생하였다.<br>\n그런 일들을 방지 및 해결하고자 Git을 도입하여 형상관리를 하기로 했다.\n\n- 1. Git 도입하기.\n- 2. Git 브런치전략.\n- 3. Git 도입 전과 후.\n\n<br>\n\n## 1. Git 도입하기.\n어떤 플랫폼을 사용할 것인가에 대해서 무료로 사용하고 비공개로 소스를 관리하기 위하여 Gitlab을 선택하였다.<br>\n> <a href=\"https://about.gitlab.com/\" target=\"blank\">Gitlab 바로가기</a>\n\n<br>\n\n### 1-1. git이란.\n\n형상 관리 도구 중 하나로써, 파일의 버전을 관리하는 시스템이다.<br>\n> 같은 형상 관리 도구로는 SVN이 있다.<br>\n\nGit은 각각의 개발 PC(로컬)와 중앙 저장소(원격/서버)에 소스를 "},{"title":"CodeIgniter에 Vue 도입하기","author":"Jay.J","date":"2021-11-20T00:00:00.000Z","categories":["VueJs"],"tags":["javascript","vue.js"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/vuejs.png","url":"/post/2021-11-20-VueInCI","con":"---\n\n<br>\n\n## CodeIgniter에 Vue 도입하기\n\n업계에서 Javascript의 프레임워크를 많이 사용하고 있어, 개인의 발전과 회사의 발전을 위해서 Vue.js를 도입해보기로 했다.<br>\n이 포스터에서는 PHP Codeigniter 기반의 환경인 Codeigniter(이하 코드이그나이터)에서 Vue를 적용시키면서 고민했던 점과 어려웠던 점을 포스팅하고자 한다.<br>\n\n<br>\n\n## 1. 코드이그나이터 환경내에 Vue 프로젝트 시작하기\n\n코드이그나이터 환경에서 Vue 프로젝트 시작하는 방법은 기존 Vue 프로젝트 시작하는 방법과 다르지 않다.<br>\n코드이그나이터 Root 폴더에서 Vue프로젝트를 생성하면 된다.<br>\n\n> Vue 생성 방법은 본 포스터에선 다루지 않는다.<br>\n> <a href=\"/blog/posts/2021-03-14-VueCLI\">Vue 프로젝트 생성하기</a>\n\n#### root폴더\n\n<img src=\"/assets/img/vue/vu"},{"title":"async 와 await","author":"Jay.J","date":"2021-08-10T00:00:00.000Z","categories":["javascript"],"tags":["javascript"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/javaScript.png","url":"/post/2021-08-10-asyncAndawait","con":"---\n\n<br>\n\n## async 와 await 란\n\nasync는 asynchronous의 약자로 비동기 방식이다.\nasync는 예전부터 많이 봤었다.\n\n스크립트를 호출할 때도 사용했었으며,\n\n```js\n<script type=\"text/javascript\" src=\"common/js/script2.js\" async></script>\n```\n> 스크립트는 비동기적으로 호출한다.<br>\n> <a href=\"/blog/posts/%2Fpost%2F2018-03-29-Where_do_you_place_the_JavaScript\" target=\"_blank\">'Where do you place the JavaScript?' 포스터</a>\n\nAjax 또한 Ajax(<b>Asynchronous</b> JavaScript and XML)의 약자로, ajax 옵션중 async옵션이 존재한다.\n\n\n```js\n$.ajax({\n    ...\n    async: false,\n    success: fu"},{"title":"ES6의 Map Filter Reduce 함수들","author":"Jay.J","date":"2021-07-15T00:00:00.000Z","categories":["javascript"],"tags":["javascript"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/javaScript.png","url":"/post/2021-07-15-MapFilterReduceInES6","con":"---\n\n<br>\n\n## ES6의 Map Filter Reduce 함수들\n\nmap, filter, reduce 함수 모두 ES6에서 추가된 함수로써, 배열(Array)에서 결과를 도출하고자 할 때 사용된다.<br>\n기존의 for문을 이용하여 loop 돌면서 결과를 도출했던 방식보다 유용하고 간결하게 사용할 수 있을 것으로 생각하며,<br>\n3개의 함수를 알아보고 정리하려고 한다.\n\n<br>\n\n## Map\n\nmap() 메서드는 배열 내의 모든 요소 각각에 대하여 주어진 함수를 호출한 결과를 모아 새로운 배열을 반환한다.\n\n### 구문\n\n```js\narr.map(callback(currentValue[, index[, array]])[, thisArg])\n```\n\n### 사용법\n\n```js\nconst numbers = [1, 2, 3];\nconst doubles = numbers.map( (num) => num * 2 );\n\nconsole.log(doubles);\n```\n> 결과값 : "},{"title":"SSR(서버사이드 렌더링)과 CSR(클라이언트 사이드 렌더링)","author":"Jay.J","date":"2021-06-26T00:00:00.000Z","categories":["HTTP"],"tags":["HTTP"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/http.png","url":"/post/2021-06-26-SSR","con":"---\n\n<br>\n\n## SSR\n\n인터넷을 사용하다 보면 내가 검색했던 키워드나 정보에 관련된 광고만 눈에 보인 적이 있을 것이다.<br>\n이는 기업에서 우리의 행동 정보를 저장하고 분석하여 활용하고 있기 때문이다.<br>\n> 개인 맞춤 광고를 하다보니 사생활 논란이 있어 현재는 개인 맞춤 광고는 중지 계획을 가지고 있다.<br>\n> \"2021년 3월 3일 - 내년 4월까지 자사 웹브라우저 크롬 사용자의 개인 정보가 담긴 ‘쿠키(사용자가 특정 웹사이트에 접속할 때 자동으로 생성되는 파일)’를 분석하는 사업을 완전히 중단\"\n\n즉, <b style=\"color:blue\">트래킹은 사용자의 행동 데이터를 수치로 나타내기 위해서 데이터를 수집하여 데이터 베이스에 저장하는 것</b>이다.<br>\n\n<br>\n\n## 트래킹 분석\n\n저장된 정보를 가지고 웹 사이트 관리자는 웹 분석을 한다.<br>\n분석을 통하여 사람들이 사이트를 사용하는 방법, 사람들이 좋아하는 것과 싫어하는 것, 방문자가 어디에"},{"title":"웹 추적 기술 - 웹 트래킹(Tracking)","author":"Jay.J","date":"2021-06-05T00:00:00.000Z","categories":["HTTP"],"tags":["HTTP"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/http.png","url":"/post/2021-06-05-Tracking","con":"---\n\n<br>\n\n## 트래킹(Tracking)\n\n인터넷을 사용하다 보면 내가 검색했던 키워드나 정보에 관련된 광고만 눈에 보인 적이 있을 것이다.<br>\n이는 기업에서 우리의 행동 정보를 저장하고 분석하여 활용하고 있기 때문이다.<br>\n> 개인 맞춤 광고를 하다보니 사생활 논란이 있어 현재는 개인 맞춤 광고는 중지 계획을 가지고 있다.<br>\n> \"2021년 3월 3일 - 내년 4월까지 자사 웹브라우저 크롬 사용자의 개인 정보가 담긴 ‘쿠키(사용자가 특정 웹사이트에 접속할 때 자동으로 생성되는 파일)’를 분석하는 사업을 완전히 중단\"\n\n즉, <b style=\"color:blue\">트래킹은 사용자의 행동 데이터를 수치로 나타내기 위해서 데이터를 수집하여 데이터 베이스에 저장하는 것</b>이다.<br>\n\n<br>\n\n## 트래킹 분석\n\n저장된 정보를 가지고 웹 사이트 관리자는 웹 분석을 한다.<br>\n분석을 통하여 사람들이 사이트를 사용하는 방법, 사람들이 좋아하는 것과 싫어하는 것"},{"title":"Cookie와 Session의 차이는 무엇일까","author":"Jay.J","date":"2021-05-23T00:00:00.000Z","categories":["HTTP"],"tags":["javascript","HTTP"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/http.png","url":"/post/2021-05-23-CookieVsSeccion","con":"---\n\n<br>\n\n## 쿠키(Cookie)\n\n사용자가 어떠한 웹 사이트를 방문할 경우 사용자의 컴퓨터에 저장하는 작은 기록 정보 파일이다.<br>\n사용자가 따로 요청하지 않아도 브라우저가 Request시에 Request Header를 넣어서 자동으로 서버에 전송한다.<br>\n사용자의 상태 정보를 로컬에 저장했다가 필요시 정보를 참조하거나 재사용 한다.<br>\n사용자 인증이 유효한 시간을 명시할 수 있으며, 유효 시간이 정해지면 브라우저가 종료되어도 인증이 유지된다는 특징이 있다.\n\n### 쿠키의 구성 요소\n\n- 이름 : 각각의 쿠키를 구별하는 데 사용되는 이름\n- 값 : 쿠키의 이름과 관련된 값\n- 유효시간 : 쿠키의 유지시간\n- 도메인 : 쿠키를 전송할 도메인\n- 경로 : 쿠키를 전송할 요청 경로\n\n### 쿠키 특징\n\n- 이름, 값, 만료일(저장 기간 설정), 경로 정보로 구성되어 있다.\n- 사용자마다 총 300개의 쿠키를 저장할 수 있다.\n- 하나의 도메인 당 20개의 쿠키를 "},{"title":"RESTful API 이란","author":"Jay.J","date":"2021-05-15T00:00:00.000Z","categories":["HTTP"],"tags":["HTTP"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/restapi.png","url":"/post/2021-05-15-RESTfulAPI","con":"---\n\n<br>\n\n## RESTful API란?\n\nREST를 기반 API를 의미합니다.<br>\nREST은 무엇인지, REST API는 무엇인지, RESTful API는 무엇인지 알아보려고합니다.\n\n<br>\n<hr>\n<br>\n\n## 1. RESTful API에서 REST 란?\n\nREST는 <span style=\"color:blue\">Representational State Transfer</span>의 약자로써 풀어서 설명하자면<br>\n<span style=\"color:red\">자원을 이름으로 구분해 해당 자원의 상태를 주고 받는 것</span>을 말한다.<br>\n<br>\n<b>웹에 존재하는 자원(이미지, 동영상, DB)에 대한 CRUD 요청을,<br>\n고유한 URI(Resource와 Method)로 표현하여 특정한 형태로 전달하는 방법이다.</b>\n> <b> CRUD : Create, Read, Update, Delete </b> <Br>\n> - Create : 데이터 생성(POS"},{"title":"통신을 위한 라이브러리, Axios","author":"Jay.J","date":"2021-05-02T00:00:00.000Z","categories":["VueJs","axios"],"tags":["javascript","axios","HTTP"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/axios.png","url":"/post/2021-05-01-Axios","con":"---\n\n<br>\n\n## &nbsp;\n\n<b>\"Axios는 브라우저, Node.js를 위한 Promise API를 활용하는 HTTP 비동기 통신 라이브러리입니다.\"</b><br>\n<br>\nAxios 공식문서에 나와 있는 Axios의 정의이다.<br>\n자바스크립트의 Fetch API와 비슷한 기능을 가지고 있다.\n\n## axios vs fetch\n\n<div class=\"table-wrapper\">\n  <table>\n    <tr>\n      <td>요청 객체에 URL을 가지고 있다.</td>\n      <td>요청 개체에 URL이 없다 .</td>\n    </tr>\n    <tr>\n      <td>쉽게 설치할 수 있는 독립 실행형 타사 패키지 이다.</td>\n      <td>대부분의 최신 브라우저에 내장되어 있다.<br>설치가 필요 없다.</td>\n    </tr>\n    <tr>\n      <td>내장된 XSRF 보호 기능 있다.</td>\n      <td>별도 보호 없다.</t"},{"title":"Vue Lifecycle 이해하기","author":"Jay.J","date":"2021-04-28T00:00:00.000Z","categories":["VueJs"],"tags":["javascript","vue.js","VueLifecycle"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/vuejs.png","url":"/post/2021-04-24-VueLifecycle","con":"---\n\n<br>\n\n## Vue Lifecycle 이해하기\n\n모든 Vue 앱은 Vue 함수로 새 Vue 인스턴스를 만드는 것부터 시작한다.\n\n```js\nvar vm = new Vue({\n  // 옵션\n})\n```\n\nVue 인스턴스는 생성될 때, 일련의 초기화 단계를 거친다.<br>\n예를들어 아래와 같은 경우가 있다.\n\n- 데이터 관찰 설정이 필요한 경우\n- 템플릿을 컴파일 하는 경우\n- 인스턴스를 DOM에 마운트하는 경우\n- 데이터가 변경되어 DOM을 업데이트 하는 경우\n\n<br>\n\n## 이미지로 보는 라이프 사이클\n\n<img src=\"/assets/img/vue/vue_lifecycle.png\" alt=\"\">\n\n<br>\n\n## 1. Create 단계\n라이프 사이클 훅에서 제일 처음 실행되는 Create 단계이다.<br>\nDOM이 생성되기 이전에 실행되는 훅으로써 DOM에 접근하거나 this.$el 을 사용하지 못한다.<br>\n<br>\n이 단계는 <b style=\"color:#197"},{"title":"Vuex가 무엇인가?","author":"Jay.J","date":"2021-04-18T00:00:00.000Z","categories":["VueJs"],"tags":["javascript","vue.js","Vuex"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/vuejs.png","url":"/post/2021-04-18-Vuex","con":"---\n\n<br>\n\n## Vuex가 무엇인가?\n\nVue.js에 대한 상태 관리 패턴이자 라이브러리이다.<br>\n모든 컴포넌트에 대한 중앙 집중식 저장소 역할을 하며 예측 가능한 방식으로 상태를 변경할 수 있다.\n\n<br>\n\n## 상태 관리란?\n\n간단한 Vue 코드로 확인해보겠다.\n\n```js\nnew Vue({\n  // 상태\n  data () {\n    return {\n      count : 0\n    }\n  },\n  // 뷰\n  template : `\n    <div> {{ count }} </div>\n  `,\n  // 액션\n  methods: {\n    increment () {\n      this.count++\n    }\n  }\n})\n```\n\n- 상태(State) : 앱을 작동하는 소스이다.\n- 뷰(View) : 상태를 보여주는 매핑이다.\n- 액션(Actions) : 사용자 입력에 대해 반응적으로 대응한다.\n\n<img src=\"/assets/img/vue/vuex_flow.pn"},{"title":"Vue Router 사용하기","author":"Jay.J","date":"2021-04-10T00:00:00.000Z","categories":["VueJs"],"tags":["javascript","vue.js","vue Router"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/vuejs.png","url":"/post/2021-04-10-VueRouter","con":"---\n\n<br>\n\n## Vue Router 란\n\n'Vue 라우터는 Vue.js (opens new window)의 공식 라우터이며,<br>\nVue.js를 사용한 싱글 페이지 앱(SPA)을 쉽게 만들 수 있도록 Vue.js의 코어와 긴밀히 통합되어 있다.'<br>\n라고 공식문서에 설명되어있다.<br>\n<br>\n싱글 페이지 앱(SPA)는 최초에 한번 페이지를 로드하고 이후부터는 특정 부분만 변경하여 페이지를 보여주는 방식이다.<br>\n<br>\n기존의 웹 서비스는 서버로부터 데이터가 변경 및 페이지를 이동 할 때 화면 전체를 렌더링 하는 방식이였다.<br>\nSPA를 사용함으로써 전체 페이지를 렌더링하는데 드는 오버헤드가 줄어들어 앱의 속도가 향상되어 더 빠른 속도를 사용자에게 제공할 수 있다.<br>\n<br>\n즉, Vue Router를 사용하면 <b>싱글 페이지 앱(SPA)을 만드는 데 필요한 URL 이동 및 특정 부분의 변경</b>을 간단히 구현할 수 있다.<br>\n\n<br>\n\n## "},{"title":"Vue-CLI","author":"Jay.J","date":"2021-03-14T00:00:00.000Z","categories":["VueJs"],"tags":["javascript","vue.js"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/vuejs.png","url":"/post/2021-03-14-VueCLI","con":"---\n\n<br>\n\n## Vue-CLI 란\n\nVue CLI은 Vue.js의 개발 환경을 쉽고 빠르게 구축할 수 있도록 도와주는 도구이다.<br>\ncli를 이용하면, 짧은 시간내에 프로젝트의 환경을 설정할 수 있다.<br>\n사용자가 조금 더 개발에 집중할 수 있도록 도와준다.\n> CLI란 Command Line Interface의 약자로 터미널을 통해 사용자와 컴퓨터가 상호 작용하는 방식을 뜻한다.<br>\n> 즉, 작업 명령은 사용자가 툴바 키보드 등을 통해 문자열의 형태로 입력하며, 컴퓨터로부터의 출력 역시 문자열의 형태로 주어진다. - <a href=\"https://ko.wikipedia.org/wiki/%EB%AA%85%EB%A0%B9_%EC%A4%84_%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4\" target=\"_blank\">위키백과</a>\n\n<br>\n\n## Vue CLI 구성요소\n\nVue CLI는 여러 패키지로 이루어져 있다.<br>\n그 "},{"title":"Vue.js란","author":"Jay.J","date":"2021-03-05T00:00:00.000Z","categories":["VueJs"],"tags":["javascript","vue.js"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/vuejs.png","url":"/post/2021-03-05-whatIsVue.js","con":"---\n\n<br>\n\n## Vue.js 란 무엇인가?\n\nVue.js의 공식문서에서는 <b>'사용자 인터페이스를 만들기 위한 프로그레시브 프레임워크'</b> 라고 설명하고 있다.<br>\n즉, 보여지는 화면을 만드는 자바스크립트 프레임워크 중의 하나이다.<br>\nVue.js는 진입장벽이 낮으며 쉽고 빠르게 개발을 할 수 있다는 것이 가장 큰 장점으로 가지고 있다.<br>\n\n> <a href=\"https://kr.vuejs.org/v2/guide/index.html\" target=\"_blank\">Vue.js 공식사이트</a>\n\n<br>\n\n## 장점 및 특징\n\n### 학습곡선이 낮다.\n\nVue.js는 웹 개발을 단순화하고 정리하기 위해 개발된 대중적인 자바스크립트 프론트엔드 프레임워크이다.<br>\n수많은 프로젝트에서 AngularJS를 사용하여 구글을 위해 작업하던 Evan You에 의해 개발되었다.<br>\n웹 UI 개발(컴포넌트, 선언형 UI, 핫 리로딩, 타임 트래블 디버깅 등)의 아이디"},{"title":"나를 괴롭히는 CORS","author":"Jay.J","date":"2020-12-20T00:00:00.000Z","categories":["html"],"tags":["html"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/CORS.png","url":"/post/2020-12-20-CORS","con":"---\n\n<br>\n\n## &nbsp;\n\n> 🚨 Access to XMLHttpRequest at 'http:// [A] ' from origin 'http:// [B] ' has been blocked by CORS policy : No 'Access-Control-Allow-Origin' header is present on the requested resource.\n\n웹 프로젝트를 구축하거나 운영하다보면 한번씩은 나타나는 오류이다.<br>\n그리고 생각보다 자주 나타나는 오류이기 때문에 누구나 한번쯤은 봤을거라고 생각한다.<br>\n그렇기에 한번 자세히 알고 넘어가야겠다고 생각해서 정리한다.<br>\n\n<br>\n\n## 교차 출처 리소스 공유(Cross-Origin Resource Sharing, CORS)\n\nCORS는 Cross-Origin Resource Sharing의 약자로 교차 출저 리소스 공유이다.<br>\n<br>\n<a href=\"https://developer.mozill"},{"title":"GET과 POST 방식","author":"Jay.J","date":"2020-09-28T00:00:00.000Z","categories":["HTTP"],"tags":["HTTP"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/http.png","url":"/post/2020-09-28-GetAndPost","con":"---\n\n<br>\n\n## &nbsp;\n\n웹 브라우저로 어떤 사이트에 접속한다고 했을 때, 사용자는 URL을 입력하여 접근한다.<br>\nHTTP 프로토콜을 통하여 사용자는 요청을 보내고 서버는 그 요청에 맞게 응답한다.<br>\n그리고 그 요청의 방식에는 크게 2가지 방식이 있고 그것이 바로 GET방식과 POST방식이다\n\n<br>\n\n## GET\n\nGET 방식은 서버로부터 어떠한 정보를 조회하기 위해서 사용되는 방식이다.<br>\nGET은 서버에게 요청할 때 URL에 요청을 담아 보낸다. <br>\nURL의 끝에 ? 를 통하여 요청을 하는데 요청의 파라미터가 여러 개일 경우 &을 이용하여 요청한다.<br>\n\n```\nwww.test.com/test?id=value&id2=value2&id3=value3\n```\n\n요청의 파라미터는 키와 값의 형식으로 보낸다.<br>\n위에 적은 url에서 키는 id이며, 값은 value으로 이루어진 문자열이다.<br>\n<br>\n이러한 방식의 요청은 URL에 변수를"},{"title":"VanillaJs","author":"Jay.J","date":"2020-08-25T00:00:00.000Z","categories":["javascript"],"tags":["javascript","VanillaJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/javaScript.png","url":"/post/2020-08-25-VanillaJs","con":"---\n\n<br>\n\n## Vanilla JS란?\nVanilla JS(바닐라 자바스크립트)란 어떠한 프레임워크와 라이브러리가 적용되지 않은 날 것의 자바스크립트를 바닐라 자바스크립트라고 한다.\n\n<br>\n\n## 왜 Vanilla JS 사용하는 것인가\n개인적인 생각이지만 배보다 배꼽이 커지는 상황도 많았던 것 같다.<br>\njQuery라는 DOM을 컨트롤 하는데에 있어서 매우 뛰어난 라이브러리가 있다.<br>\n하지만 특정한 곳에서 한번만 사용할 것인데 그를 위해 jQuery를 사용한다면 효율적인 면에서 떨어진다.<br>\njQuery 또한 자바스크립트의 라이브러리이기 때문에 순수한 자바스크립트보다 속도면에서 성능이 떨어진다.<br>\n<br>\n또한 이전까지의 자바스크립트 버전은 DOM에 접근하려면 jQuery에 비해 길게 작성해야했기에 조금 더 편리한 jQuery를 개발하는 데 편하고 좋았다고 생각한다.<br>\n\n```js\n// class가 item 인 요소에 이벤트 바인딩\n\n// java"},{"title":"자바스크립트 엄격모드?","author":"Jay.J","date":"2020-06-11T00:00:00.000Z","categories":["javascript"],"tags":["javascript"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/javaScript.png","url":"/post/2020-06-11-use_strict","con":"---\n\n<br>\n\n## 자바스크립트 엄격모드란 ?\n\nECMAScript 5 에서 소개되었다.<br>\n기본으로 우리 사용하는 자바스크립트는 <b>\"느슨한모드(sloppy mode)\"</b>라고 불리며<br>\n문법이나 살짝 벗어나는 오류 정도는 조용히 무시하고 작동되었다.<br>\n<b>\"엄격한 모드(strict mod)\"</b>를 사용하면 조금 더 디테일하게 문법이나 오류를 잡아낸다.\n\n<br>\n\n## 엄격모드를 사용하려면\n\n사용법은 간단하다. <br>\n엄격모드를 사용하기 위해서는 스크립트를 작성하기 전 최상단에 '\"use strict\";'를 작성해준다<br>\n\n```js\n\n'use strict';\n\nfunction A(){\n  ...\n}\n\nvar b = 'hi';\n\n```\n\n## 무엇이 다른가\n\n엄격모드를 설명하면서 조금 더 디테일하게 문법과 오류를 잡아낸다고 설명했다.<br>\n\n```js\n// 느슨한 모드\n\nb = 'hi';\nvar undefined = 5;\nfunction sum"},{"title":"Javascript에서의 This","author":"Jay.J","date":"2020-04-15T00:00:00.000Z","categories":["javascript"],"tags":["javascript"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/javaScript.png","url":"/post/2020-04-15-javascriptThis","con":"---\n\n<br>\n\n## Javascript에서의 This\n\nthis가 무엇이냐라고 누군가 물어봤을 때 의미 자체에 순간 망설였던 적이 있었다.<br>\n그래서 this는 무엇이고 어떻게 동작하는 지에 대해 포스팅 하려고 한다.\n\n## This 무엇이냐 넌\nthis. 자바스크립트의 this는 호출한 객체가 저장되어있는 속성이다.\n\n```js\nconsole.log(this);  // window\n```\n\n기본적으로 this는 window 객체의 정보를 저장하고 있다.<br>\n기본적으로 사용하는 메서드들 또한 상단에의 window를 통해 호출하기 때문이다.\n\n```js\nwindow.console.log(this);  // window\n```\n> console에 찍힌 window 객체를 자세히보기를 열어서 찾으면 console를 찾을 수 있을 것이다.\n\nwindow객체의 console 객체의 log 메서드를 통하여 호출하였기에 this는 window의 정보를 저장하고 있다.\n\n<br>\n\n#"},{"title":"웹 접근성(견고성)","author":"Jay.J","date":"2020-03-22T00:00:00.000Z","categories":["html"],"tags":["html","Web Accessibility"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/accessibility.jpg","url":"/post/2020-03-22-webAccessibility_5","con":"---\n\n<br>\n\n## 운용의 용이성\n사용자 인터페이스 구성요소는 조작 가능하고 내비게이션 할 수 있어야 한다.\n\n- [4.1.1 마크업 오류 방지](#411-마크업-오류-방지)\n- [4.2.1 웹 애플리케이션 접근성 준수](#421-웹-애플리케이션-접근성-준수)\n\n<br>\n\n### 4.1.1 마크업 오류 방지\n마크업 언어의 요소는 열고 닫음, 중첩 관계 및 속성 선언에 오류가 없어야 한다.\n\n#### 1) 요소의 열고 닫음\n\n##### <b style='color:red'>잘못된 소스</b>\n```HTML\n<ul>\n  <li>목록</li>\n  <li>목록</li>\n  <li>목록</li>\n<p>내용</p>\n```\n\n##### <b style='color:blue'>잘된 소스</b>\n```HTML\n<ul>\n  <li>목록</li>\n  <li>목록</li>\n  <li>목록</li>\n</ul>\n<p>내용</p>\n```\n\n<br>\n\n#### 2) 중첩 관계\n\n##### <b style="},{"title":"웹 접근성(이해의 용이성)","author":"Jay.J","date":"2020-03-21T00:00:00.000Z","categories":["html"],"tags":["html","Web Accessibility"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/accessibility.jpg","url":"/post/2020-03-21-webAccessibility_4","con":"---\n\n<br>\n\n## 이해의 용이성\n콘텐츠는 이해할 수 있어야 한다.\n\n- [3.1.1 기본 언어 표시](#311-기본-언어-표시)\n- [3.2.1 사용자 요구에 따른 실행](#321-사용자-요구에-따른-실행)\n- [3.3.1 콘텐츠의 선형화](#331-콘텐츠의-선형화)\n- [3.3.2 표의 구성](#332-표의-구성)\n- [3.4.1 레이블 제공](#341-레이블-제공)\n- [3.4.2 오류 정정](#342-오류-정정)\n\n<br>\n\n### 3.1.1 기본 언어 표시\n주로 사용하는 언어를 명시해야 한다.\n\n```HTML\n<html lang=”ko”>\n```\n> HTML5\n\n<br>\n\n### 3.2.1 사용자 요구에 따른 실행\n사용자가 의도하지 않은 기능 (새 창, 초점 변화 등)은 실행되지 않아야 한다.\n\n#### 1) 페이지 진입시 뜨는 새 창(팝업)\n\n<img src=\"/assets/img/webAccessibility/firstpopup.jpg\" alt=\"\" style=\"b"},{"title":"웹 접근성(운용의 용이성)","author":"Jay.J","date":"2020-03-14T00:00:00.000Z","categories":["html"],"tags":["html","Web Accessibility"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/accessibility.jpg","url":"/post/2020-03-14-webAccessibility_3","con":"---\n\n<br>\n\n## 운용의 용이성\n사용자 인터페이스 구성요소는 조작 가능하고 내비게이션 할 수 있어야 한다.\n\n- [2.1.1 키보드 사용 보장](#211-키보드-사용-보장)\n- [2.1.2 초점 이동](#212-초점-이동)\n- [2.1.3 조작 가능](#213-조작-가능)\n- [2.2.1 응답시간 조절](#221-응답시간-조절)\n- [2.2.2 정지 기능 제공](#222-정지-기능-제공)\n- [2.3.1 깜빡임과 번쩍임 사용 제한](#231-깜빡임과-번쩍임-사용-제한)\n- [2.4.1 반복 영역 건너뛰기](#241-반복-영역-건너뛰기)\n- [2.4.2 제목 제공](#242-제목-제공)\n- [2.4.3 적절한 링크 텍스트](#243-적절한-링크-텍스트)\n\n<br>\n\n### 2.1.1 키보드 사용 보장\n모든 기능은 키보드만으로도 사용할 수 있어야 한다. (PC웹)<br>\n터치(touch) 기반 모바일 기기의 모든 컨트롤은 누르기 동작으로 제어할 수 있어야 한다. (모바일웹)\n\n#"},{"title":"웹 접근성(인식의 용이성)","author":"Jay.J","date":"2020-03-07T00:00:00.000Z","categories":["html"],"tags":["html","Web Accessibility"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/accessibility.jpg","url":"/post/2020-03-07-webAccessibility_2","con":"---\n\n<br>\n\n## 인식의 용이성\n모든 콘텐츠는 사용자가 인식할 수 있어야 한다.\n\n- [1.1.1 적절한 대체 텍스트 제공](#111-적절한-대체-텍스트-제공)\n- [1.2.1 자막 제공](#121-자막-제공)\n- [1.3.1 색에 무관한 콘텐츠 인식](#131-색에-무관한-콘텐츠-인식)\n- [1.3.2 명확한 지시사항 제공](#132-명확한-지시사항-제공)\n- [1.3.3 텍스트 콘텐츠의 명도 대비](#133-텍스트-콘텐츠의-명도-대비)\n- [1.3.4 자동 재생 금지](#134-자동-재생-금지)\n- [1.3.5 콘텐츠 간의 구분](#135-콘텐츠-간의-구분)\n\n<br>\n\n### 1.1.1 적절한 대체 텍스트 제공\n텍스트 아닌 콘텐츠는 그 의미나 용도를 이해할 수 있도록 대체 텍스트를 제공해야 한다.\n\n#### 1) 의미가 있는 이미지는 대체 텍스트를 제공한다.\n\n<img src=\"/assets/img/webAccessibility/need_alt_img.png\" alt=\""},{"title":"웹 접근성이란","author":"Jay.J","date":"2020-02-29T00:00:00.000Z","categories":["html"],"tags":["html","Web Accessibility"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/accessibility.jpg","url":"/post/2020-02-29-webAccessibility_1","con":"---\n\n<br>\n\n## &nbsp;\n\n이전 회사에서 웹 접근성에 대해 공부를 했었다.<br>\n공부했던 내용을 정리해두면 좋겠다는 생각이 있었는데,<br>\n미루고 미루다가 이제 정리를 한다.\n\n## 웹 접근성(Web Accessibility)이란\n\n웹 접근성이란 어떠한 사용자가 접근을 하더라도, 동일한 정보를 제공할 수 있도록 보장하는 것이다.<br>\n즉, 장애인, 고령자등 모든 사람이 비장애인과 차별되지 않은 정보를 얻을 수 있어야한다.<br>\n간단한 예로 이미지가 제공된다고 했을 때, 시각적으로 불편한 사람은 이미지의 정보를 얻을 수 없다.<br>\n그렇기에 이미지에 대한 대체 텍스트가 제공되어 텍스트로 정보를 전달할 수 있어야한다.\n> 시각장애인의 경우, 사이트를 읽어주는 스크린리더라는 프로그램으로 정보에 접근한다.<br>\n> 스크린리더는 이미지를 읽어주지 못하기 때문에 이미지 태그의 alt 속성을 이용하여 대체 텍스트를 제공해야한다.\n\n<br>\n\n## 4가지 원칙\n\n- <b>인"},{"title":"Sass & SCSS 란?","author":"Jay.J","date":"2019-08-31T00:00:00.000Z","categories":["css"],"tags":["sass","scss","css"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/sass.png","url":"/post/2019-08-31-whatIsSass","con":"---\r\n\r\n<br>\r\n\r\n## &nbsp;\r\n\r\n최근 프론트쪽을 담당하는 직군의 기술 스택을 보면 Sass를 심심찮게 볼 수 있습니다.\r\n그래서 Sass는 무엇인가에 대해서 알아보려고 합니다.\r\n\r\n> 본 글에서는 Sass에 대해서만 알아보며, 문법과 컴파일 방법에 대해서는 다루지 않습니다.\r\n\r\n<br>\r\n\r\n## Sass 란?\r\nSass는 Syntactically Awesome Style Sheets의 약자이며,\r\nCSS를 우리가 조금 더 편하게 사용하기 위해 확장한 언어입니다.\r\n그러나 웹에서는 CSS만 직접 동작하기 때문에 Sass는 웹에서 사용하기 위해서는 컴파일을 해주어야 합니다.\r\n그러기에 Sass는 <b>CSS Preprocessor(CSS 전처리기)</b>라고 불립니다. \r\n> 전처리기 란?\r\n> 프로그램을 만들 때 소스파일 > 전처리기 -> 컴파일러 ->  실행파일 순으로 실행되는데,\r\n> <b>전처리기(Preprocessor)</b>는 소스 코딩을 한 후 컴파일"},{"title":"CI(codeigniter)의 MVC패턴 프로젝트 경험","author":"Jay.J","date":"2019-06-05T00:00:00.000Z","categories":["Architecture"],"tags":["Architecture","Design Pattern","Retrospect"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/codeigniter.png","url":"/post/2019-06-05-CodeigniterAndMVC_Use","con":"---\n\n<br>\n\n## CI(codeigniter)의 MVC패턴 프로젝트 후기\n\n회사에서 개발팀에 코드이그나이터를 도입하였다.<br>\n개발팀에 도입한다고 해서 사실 크게 관심이 없었으며,<br>\n큰 영향도 없을 것이라고 생각했다.<br>\n<br>\n하지만 퍼블리셔 입장에서도 기존의 방식과 조금씩 달랐고<br>\n하나씩 경험했던 내용을 기록해두려고 한다.<br>\n\n## Codeigniter란\n\nCodeigniter(이하 코드이그나이터)란 PHP로 작성된 웹 프레임워크다.<br>\nMVC패턴으로 동작한다.<br>\n> <a href=\"/blog/posts/%2Fpost%2F2019-05-09-whatIsMVC\" target=\"_blank\">MVC에 관한 포스팅</a>\n\n<br>\n\n## 기존의 방식과 달라진 퍼블리셔 업무\n\n기존의 방식과 제일 크게 달라졌던 점은 역시 MVC패턴을 사용함에 따른 변화이다.<br>\n\n<img src=\"/assets/img/architecture/mvc.png\" a"},{"title":"MVC패턴에 대해서","author":"Jay.J","date":"2019-05-09T00:00:00.000Z","categories":["Architecture"],"tags":["Architecture","Design Pattern"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/mvc.jpg","url":"/post/2019-05-09-whatIsMVC","con":"---\n\n<br>\n\n## MVC 란\n\nMVC는 Model, View, Controller의 약자이다.<br>\nMVC는 사용자 인터페이스, 데이터 및 논리 제어를 구현하는데 널리 사용되는 소프트웨어 디자인 패턴이다.<br>\n소프트웨어의 비즈니스 로직과 화면을 구분하는데 중점을 두고 있다.<br>\n\n<img src=\"/assets/img/architecture/mvc.png\" alt=\"\" style=\"max-width:500px\">\n\nUser는 Controller에게 요청하고, Controller는 Model에게 명령을 보내고,<br>\nModel은 해당의 데이터를 View에게 제공하여, User는 View를 통해 정보를 얻을 수 있다.<br>\n<br>\n하나 하나의 기능을 자세히 살펴보면 아래와 같다.<br>\n<br>\n\n### Model\n\n모델(model)이란 어떠한 동작을 수행하는 코드를 말한다.<br>\n모델은 데이터가 무엇인지를 정의한다.<br>\n데이터 자체는 사용자에게 어떻게 보일지"},{"title":"Require.js 을 사용했던 프로젝트에 대한 회고","author":"Jay.J","date":"2019-02-10T00:00:00.000Z","categories":["javascript"],"tags":["javascript","AMD","require.js","Retrospect"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/javaScript.png","url":"/post/2019-02-10-requirejs_use","con":"---\n\n<br>\n\n## Require.js 을 사용했던 프로젝트에 대한 회고\n\n기존의 프로젝트를 진행할 때에는 필요한 기능을 전역 함수 파일에 추가하여 사용했다.<br>\n전역 파일에 기능을 추가하여 사용하다보니 기능이 늘어날 수록 코드는 복잡해져갔으며 <br>\n모든 페이지에서 불필요한 기능까지 전부 호출하는게 비효율적으로 느껴졌다.<br>\n<br>\n그렇기에 최근 알게 되었던 AMD/Require.js에 관심을 더욱 가지게 되었으며, <br>\n신규 프로젝트에 Require.js를 사용해보기 했다.<br>\n> <a href=\"/blog/posts/%2Fpost%2F2018-06-23-AMD_requirejs\">AMD / Require.js에 대한 포스팅</a>\n\n<br>\n\n### 프로젝트 초반\n\n디자인을 보고 퍼블리싱하며, 공통으로 쓰이는 기능과 특정 페이지에서 사용 되는 기능을 파악했다.<br>\n공통으로 쓰이는 기능들 가운데, 기존 전역 함수에 있었던 기능들은 분리하여 모듈화 시키며"},{"title":"HTTP 와 HTTPS, Status Code","author":"Jay.J","date":"2018-11-18T00:00:00.000Z","categories":["HTTP"],"tags":["HTTP"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/httphttps.jpg","url":"/post/2018-11-18-HTTP_HTTPS_Status_Code","con":"---\r\n\r\n<br>\r\n\r\n## &nbsp;\r\n  \r\n인터넷을 사용하다보면 HTTP와 HTTPS로 시작되는 주소를 볼 수 있다.    \r\n어떤 차이가 있어서 HTTP와 HTTPS를 나눠서 쓰는지 알아보려고 한다.  \r\n\r\n<br>\r\n\r\n### HTTP\r\nHTTP는 <b>Hyper Text Transfer Protocol</b>의 약자로  \r\nWorld Wide Web에서 사용되는 기본 프로토콜이며 이 프로토콜은 메시지가 형식화되고  \r\n전송되는 방법과 다양한 명령에 대한 응답으로 <b>웹 서버와 브라우저가 수행해야하는 작업을 정의</b>한다.  \r\n<br>\r\n  \r\n### HTTPS\r\nHTTPS는 <b>Hyper Text Transfer Protocol over Secure sockets layter</b>의 약자이다.  \r\n기존의 HTTP는 보안장치 없이 그대로 정보를 전송하기에 보안에 취약하다.  \r\n그 보안에 취약한 문제를 해결하고자 HTTP에 secure sockets lay"},{"title":"AMP Conference","author":"Jay.J","date":"2018-11-05T00:00:00.000Z","categories":["conference"],"tags":["conference"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/amp.jpg","url":"/post/2018-11-05-amp_conference","con":"---\r\n\r\n<br>\r\n\r\n## AMP(Accelerated Mobile Pages)\r\nAMP는 Accelerated Mobile Pages의 약자로 Google에서 만든 오픈소스이며,  \r\n웹 페이지를 빠르고 번개와 같이 즉시 로딩 될 수 있게  \r\n모바일 <b>웹의 성능을 높이기 위한 목적을 가지고 있는 오픈소스 라이브러리</b>다.\r\n  \r\n<br>\r\n  \r\n### AMP의 특징\r\nAMP의 특징으로는 <b>즉시 페이지를 로드한다는 큰 틀안에서 이루어진다</b>.  \r\n비동기 스크립트만을 이용하여 페이지의 성능을 개선하고,  \r\n이미지와 iframe 등도 다운로드 전에 크기와 위치를 잡아 성능을 개선한다.  \r\n또한 css를 인라인으로 작성하여 호출할 때 보다 페이지를 더 빠르게 로드한다.  \r\n> 추가적인 정보 : <a href=\"https://www.ampproject.org/ko/learn/about-how/\" target=\"_blank\">https://www.ampproj"},{"title":"Node.js 란?","author":"Jay.J","date":"2018-07-08T00:00:00.000Z","categories":["nodejs"],"tags":["nodejs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/nodejs.png","url":"/post/2018-07-08-node_init","con":"---\r\n\r\n<br>\r\n\r\n## Node.js 란?\r\n\r\nJavaScript는 Browser에서 작동하는 JavaScript와 V8 JavaScript 엔진으로 빌드된 JavaScript 런타임 환경에서 돌아가는 JavaScript가 있다.  \r\n  \r\n<b>Node.js는 V8 JavaScript 엔진으로 빌드된 JavaScript 런타임 환경에서 돌아가는 JavaScript 이다.</b>  \r\n런타임 환경에서 JavaScript로 서버를 구성할 수 있는 것일 뿐, Node.js 자체는 서버가 아니다.  \r\n> node.js !== 서버  \r\n\r\n<br>\r\nBrowser에서 돌아가는 JavaScript와 런타임 환경에서 돌아가는 JavaScript는 차이가 있다.  \r\n한 가지의 차이를 예를 들면,  \r\nBrowser에서 돌아가는 JavaScript에서 전역객체는 window 이지만,  \r\n런타임 환경에서 돌아가는 JavaScript에서 전역객체는 global 이다.  \r\n  \r\n"},{"title":"AMD & require.js","author":"Jay.J","date":"2018-06-23T00:00:00.000Z","categories":["javascript"],"tags":["javascript","AMD","require.js"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/javaScript.png","url":"/post/2018-06-23-AMD_requirejs","con":"---\n\n<br>\n\n## AMD\n\nAMD(Asynchronous Module Definition)란 모듈을 정의하는 방법과 모듈이 필요할 때 비동기로 로딩하는 방법을 정의한 API 이다.\nAMD는 세 가지의 핵심 개념을 가지고 동작한다.\n<br>\n#### 1. 동적 로딩\n\n동적 로딩(Dynamic Loading, Lazy Loading)은 페이지 렌더링을 방해하지 않으면서 필요한 파일만 로딩할 수 있다.\n\n브라우저는 문서를 위에서 아래로 읽어내려오며, \\<script\\> 태그를 만나면 \\<script\\>의 HTTP 요청과 다운로드, 파싱(Parsing), 실행이 일어나는 동안 브라우저는 다른 동작을 하지 않는다.\n그로 인하여 페이지 렌더링은 느려지는데, 이를 최적화 하는 기법으로 \\<script\\> 태그를 \\<body\\> 태그의 마지막에 배치하는 방법이 있다.\n하지만 이 방법 또한 첫 렌더링과 첫 인터랙션에 필요하지 않은, 페이지에 필요한 모든 JavaScript를 로딩하기 때문에 "},{"title":"Javascript Call Stack and Event Loop","author":"Jay.J","date":"2018-05-11T00:00:00.000Z","categories":["javascript"],"tags":["javascript"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/javaScript.png","url":"/post/2018-05-11-Call_Stack_and_Event_Loop","con":"---\n\n<br>\n\n## Call Stack and Event Loop\n> 호출 스택 및 이벤트 루프\n\n<br>\n\n### 자바 스크립트 엔진\njavascript 를 해석하고 실행하는 인터프리터.\n> 인터프리터 : 프로그래밍 언어의 소스 코드를 바로 실행하는 컴퓨터 프로그램 또는 환경을 말한다.\n\n엔진에는 4가지로 구성되어있다.\n- [Heap](#heap)\n- [CallStack](#callstack)\n- [EventQueue](#eventqueue)\n- [EventLoop](#eventloop)\n\n<br>\n\n### Heap\n객체나 변수 값들이 들어가있는 영역으로 메모리의 할당이 일어나는 곳이다.\n\n<br>\n\n### CallStack\n\nCall Stack은 코드 실행에 따라 호출 스택(task)이 쌓이는 곳이다.<br>\n자바스크립트는 기본적으로 싱글 쓰레드 기반 언어이다.<br>\n따라서 코드 순서에 따라 호출 스택(task)이 쌓이면 작업 시 그 순서에 맞게 한번에 하나씩 호출하여 처"},{"title":"Javascript 실행 컨텍스트","author":"Jay.J","date":"2018-05-04T00:00:00.000Z","categories":["javascript"],"tags":["javascript"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/javaScript.png","url":"/post/2018-05-04-Execution_Context","con":"---\r\n\r\n<br>\r\n\r\n## Javascript 실행 컨텍스트\r\n\r\n<br>\r\n\r\n### 실행 컨테스트란\r\n\r\n자바스크립트가 실행될 때 생성되는 실행 단위를 실행 컨텍스트라고 부른다.  \r\n자바스크립트가 실행되면 함수들이 차곡차곡 <b>콜 스택(Call Stack)</b>이라 곳에 쌓이는데,  \r\n<b>실행 컨텍스트는 Call Stack에 쌓이는 하나하나의 실행 정보</b>이다.\r\n\r\n```js\r\n\r\nconsole.log('전역 스코프');\r\nfunction first(){\r\n  console.log('First Context');\r\n  second();\r\n}\r\nfunction second(){\r\n  console.log('Second Context');\r\n}\r\nfirst();\r\n\r\n// 컨텍스트 실행순서\r\n// 1. console.log('전역 스코프') 컨텍스트에 들어감  \r\n// 2. first함수가 컨텍스트에 들어감  \r\n// 3. second함수가 컨텍스트에 들어감\r\n/"},{"title":"How do you stop event propagation?","author":"Jay.J","date":"2018-04-09T00:00:00.000Z","categories":["javascript"],"tags":["javascript"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/javaScript.png","url":"/post/2018-04-09-stop_event_propagation","con":"---\n\n<br>\n\n## How do you stop event propagation?\n> 이벤트 전파를 어떻게 중지합니까?\n\n<br>\n\n### 이벤트 전파란?\n\n#### html\n```html\n<div class=\"boxDiv click01\">\n    <p>3</p>\n    <div class=\"boxDiv click02\">\n        <p>2</p>\n        <div class=\"boxDiv click03\">\n            <p>1</p>\n        </div>\n    </div>\n</div>\n<p class=\"result\"></p>\n```\n#### css\n```css\n.boxDiv{border:1px solid #000;padding:20px}\n.click01{width:300px;margin:0 50px;background:#aaa}\n.click02{background:#ddd}\n.click03{background:#fff}\n```\n#### js\n```js"},{"title":"Where do you place the JavaScript?","author":"Jay.J","date":"2018-03-29T00:00:00.000Z","categories":["javascript"],"tags":["javascript"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/javaScript.png","url":"/post/2018-03-29-Where_do_you_place_the_JavaScript","con":"---\r\n\r\n<br>\r\n\r\n## Where do you place the JavaScript?\r\n> JavaScript는 어디에 두어야합니까?\r\n\r\n<br>\r\n\r\n### 1. Head, Body\r\nhead Tag 섹션에 삽입하거나 body Tag 섹션의 시작 부분에 놓는 방법은 안좋다.  \r\n해당 부분에 위치시킬 경우 문서는 페이지 로드시  \r\n페이지를 읽다가 script Tag를 만날 경우 페이지의 분석을 멈추고  \r\n스크립트를 로드한 후 페이지를 읽기 때문에 성능면에서 안좋다.  \r\n<br>\r\n\r\n#### 브라우저가 웹 사이트를 로드 할 때 일어나는 일\r\n1. 문서 가져 온다 (예 : index.html, index.asp, main.php ...등)\r\n2. HTML 구문 분석한다.\r\n3. 파서는 문서를 위에서 부터 아래로 읽는다.  \r\n    중간에 외부 스크립트 파일을 참조하는 script Tag를 발견한다.\r\n4. 브라우저가 스크립트 파일을 확인하고 요청한다.  \r\n    "}]}