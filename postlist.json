{"postlist":[{"title":"Render and Commit","author":"Jay.J","date":"2024-06-19T00:00:00.000Z","categories":["javascript","ReactJs"],"tags":["javascript","ReactJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/react.png","url":"/post/2024-06-19-2_3_Render_and_Commit","con":"---\r\n\r\n<br>\r\n\r\n## Render and Commit\r\n> 렌더링 그리고 커밋\r\n\r\n UI를 요청하고 제공하는데까지 세 단계로 나눌 수 있다.<br>\r\n 음식점이라고 상상하고 이 단계들을 표현해보겠다.\r\n\r\n1. 렌더링 <b>트리거</b> (손님의 주문을 주방으로 전달)\r\n2. 컴포넌트 <b>렌더링</b> (주방에서 주문 준비하기)\r\n3. DOM에 <b>커밋</b> (테이블에 주문한 요리 내놓기)\r\n\r\n<br>\r\n\r\n<img src=\"/assets/img/react/i_rerender.png\" alt=\"\" style=\"max-width:500px\">\r\n\r\n<br>\r\n\r\n### 1단계: 렌더링 트리거\r\n컴포넌트 렌더링이 일어나는 데에는 두 가지 이유가 있다.\r\n\r\n1. 컴포넌트의 초기 렌더링인 경우\r\n2. 컴포넌트의 state가 업데이트된 경우\r\n\r\n#### 초기 렌더링\r\n\r\n앱을 시작할 때 초기 렌더링을 트리거해야 한다<br>\r\nDOM 노드와 함께 ```createRoot"},{"title":"State as a Snapshot","author":"Jay.J","date":"2024-06-19T00:00:00.000Z","categories":["javascript","ReactJs"],"tags":["javascript","ReactJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/react.png","url":"/post/2024-06-19-2_4_State_as_a_Snapshot","con":"---\r\n\r\n<br>\r\n\r\n## State as a Snapshot\r\n> 스냅샷으로서의 State\r\n\r\n### state를 설정하면 렌더링이 동작한다\r\n클릭과 같은 사용자 이벤트에 반응하여 사용자 인터페이스가 직접 변경된다고 생각할 수 있다.\r\n\r\n```js\r\nimport { useState } from 'react';\r\n\r\nexport default function Form() {\r\n  const [isSent, setIsSent] = useState(false);\r\n  const [message, setMessage] = useState('Hi!');\r\n  if (isSent) {\r\n    return <h1>Your message is on its way!</h1>\r\n  }\r\n  return (\r\n    <form onSubmit={(e) => {\r\n      e.preventDefault();\r\n      setIsSent(true);\r\n      sendMessage(mes"},{"title":"Queueing a Series of State Updates","author":"Jay.J","date":"2024-06-19T00:00:00.000Z","categories":["javascript","ReactJs"],"tags":["javascript","ReactJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/react.png","url":"/post/2024-06-19-2_5_Queueing_a_Series_of_State_Updates","con":"---\r\n\r\n<br>\r\n\r\n## Queueing a Series of State Updates\r\n> state 업데이트 큐\r\n\r\n### React state batches 업데이트\r\n```setNumber(number + 1)```를 세 번 호출하므로 “+3” 버튼을 클릭하면 세 번 증가할 것으로 예상할 수 있다.\r\n\r\n```js\r\nimport { useState } from 'react';\r\n\r\nexport default function Counter() {\r\n  const [number, setNumber] = useState(0);\r\n\r\n  return (\r\n    <>\r\n      <h1>{number}</h1>\r\n      <button onClick={() => {\r\n        setNumber(number + 1);\r\n        setNumber(number + 1);\r\n        setNumber(number + 1);\r\n      }}>+3</button>"},{"title":"Updating Objects in State","author":"Jay.J","date":"2024-06-19T00:00:00.000Z","categories":["javascript","ReactJs"],"tags":["javascript","ReactJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/react.png","url":"/post/2024-06-19-2_6_Updating_objects_in_state","con":"---\r\n\r\n<br>\r\n\r\n## Updating Objects in State\r\n> 객체 State 업데이트하기\r\n\r\n### 변경이란?\r\nState에는 모든 종류의 자바스크립트 값을 저장할 수 있다.\r\n\r\n```js\r\nconst [x, setX] = useState(0);\r\nsetX(5);\r\n```\r\nx에 들어가는 값들은 변경할 수 없거나 “읽기 전용”을 의미하는 “불변성”을 가진다.<br/>\r\n값을 교체 하기 위해서는 리렌더링이 필요한다.(<b>setX를 이용</b>)<br/>\r\nx state는 0에서 5로 바뀌었지만, 숫자 0 자체 는 바뀌지 않았다.<br/>\r\n숫자, 문자열, 불리언과 같이 자바스크립트에 정의되어 있는 원시 값들은 변경할 수 없다.\r\n\r\n<br>\r\n\r\n```js\r\nconst [position, setPosition] = useState({ x: 0, y: 0 });\r\n```\r\n기술적으로 객체 자체 의 내용은 바꿀 수 있다.<br>\r\n이것을 <b>변경(mutati"},{"title":"Updating Arrays In State","author":"Jay.J","date":"2024-06-19T00:00:00.000Z","categories":["javascript","ReactJs"],"tags":["javascript","ReactJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/react.png","url":"/post/2024-06-19-2_7_Updating-arrays-in-state","con":"---\r\n\r\n<br>\r\n\r\n## Updating Arrays In State\r\n> 배열 State 업데이트하기\r\n\r\n### 변경하지 않고 배열 업데이트하기\r\n객체와 마찬가지로 React state에서 배열은 읽기 전용으로 처리해야 한다.<br>\r\n즉 ```arr[0] = 'bird'```처럼 배열 내부의 항목을 재할당해서는 안 되며 ```push()```나 ```pop()```같은 함수로 배열을 변경해서는 안된다.<br>\r\n<br>\r\n배열을 업데이트할 때마다 ```filter()```나 ```map()```을 이용하여 새 배열을 state 설정 함수에 전달해야 한다.\r\n<br>\r\n\r\n<table>\r\n  <caption>Updating Arrays In State</caption>\r\n  <thead>\r\n    <tr>\r\n      <th scope='col'></th>\r\n      <th scope='col'>비선호(배열을 변경)</th>\r\n      <th scope='col'>선호"},{"title":"Responding to Events","author":"Jay.J","date":"2024-06-18T00:00:00.000Z","categories":["javascript","ReactJs"],"tags":["javascript","ReactJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/react.png","url":"/post/2024-06-18-2_1_Responding_to_Events","con":"---\r\n\r\n<br>\r\n\r\n## Responding to Events\r\n> 이벤트에 응답하기\r\n\r\n<br>\r\n\r\n### 이벤트 핸들러 추가하기\r\n이벤트 핸들러 추가를 위해서는 먼저 함수를 정의하고 이를 적절한 JSX 태그에 prop 형태로 전달해야 한다.\r\n\r\n```js\r\nexport default function Button() {\r\n  function handleClick() {\r\n    alert('You clicked me!');\r\n  }\r\n\r\n  return (\r\n    <button onClick={handleClick}>\r\n      Click me\r\n    </button>\r\n  );\r\n}\r\n```\r\n>Button 컴포넌트 내부에 handleClick 함수를 선언한다.<br>\r\n>해당 함수 내부 로직을 구현합니다. 이번에는 메시지를 표시하기 위해 alert를 사용한다.<br>\r\n>```<button>``` JSX에 ```onClick={handleClick}```을 추"},{"title":"State A Components Memory","author":"Jay.J","date":"2024-06-18T00:00:00.000Z","categories":["javascript","ReactJs"],"tags":["javascript","ReactJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/react.png","url":"/post/2024-06-18-2_2_State_A_Components_Memory","con":"---\r\n\r\n<br>\r\n\r\n## State: A Components Memory\r\n> State: 컴포넌트의 기억 저장소\r\n\r\n<br>\r\n\r\n### 일반 변수로 충분하지 않은 경우\r\n```js\r\nimport { sculptureList } from './data.js';\r\n\r\nexport default function Gallery() {\r\n  let index = 0;\r\n\r\n  function handleClick() {\r\n    index = index + 1;\r\n  }\r\n\r\n  let sculpture = sculptureList[index];\r\n  return (\r\n    <>\r\n      <button onClick={handleClick}>\r\n        Next\r\n      </button>\r\n      <h2>\r\n        <i>{sculpture.name} </i> \r\n        by {sculpture.artist}\r\n      </h2>\r\n      <h"},{"title":"Your First Component","author":"Jay.J","date":"2024-06-17T00:00:00.000Z","categories":["javascript","ReactJs"],"tags":["javascript","ReactJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/react.png","url":"/post/2024-06-17-1_1_Your_First_Component","con":"---\r\n\r\n<br>\r\n\r\n## Your First Component\r\n> 첫번째 컴포넌트\r\n<br>\r\n\r\n### 컴포넌트: UI 구성 요소 \r\n\r\nReact에서의 컴포넌트 : 마크업, CSS, JavaScript를 앱의 재사용 가능한 사용자 정의 UI 요소.<br>\r\n컴포넌트를 작성, 순서 지정 및 중첩하여 전체 페이지를 디자인할 수 있다.\r\n\r\n<br>\r\n\r\n### 컴포넌트 정의하기\r\n\r\nReact 컴포넌트는 마크업으로 뿌릴 수 있는 JavaScript 함수이다. <br/>\r\n\r\n```js\r\nexport default function Profile() {\r\n  return (\r\n    <img\r\n      src=\"https://i.imgur.com/MK3eW3Am.jpg\"\r\n      alt=\"Katherine Johnson\"\r\n    />\r\n  )\r\n}\r\n\r\n```\r\n\r\n<br>\r\n\r\n#### Step 1: 컴포넌트 내보내기\r\nexport 를 이용하여 내보낸다.<br>\r\n``"},{"title":"Your First Component","author":"Jay.J","date":"2024-06-17T00:00:00.000Z","categories":["javascript","ReactJs"],"tags":["javascript","ReactJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/react.png","url":"/post/2024-06-17-1_2_Importing_and_Exporting_Componentsy","con":"---\r\n\r\n<br>\r\n\r\n## Importing and Exporting Components\r\n> 컴포넌트 import 및 export 하기\r\n<br>\r\n\r\n### Root 컴포넌트란\r\n\r\nApp.js 라는 파일이 대부분 만들어지고 이게 루트이며, 모든 컴포넌트는 이런 루트 안에 존재하게된다.<br/>\r\n만약 Next.js 같은 프레임워크일 경우, 매 페이지 마다 Root component 가 달라진다.\r\n\r\n<br>\r\n\r\n### 컴포넌트를 import 하거나 export 하는 방법\r\n\r\n1. 컴포넌트를 추가할 JS 파일을 생성한다.\r\n2. 새로 만든 파일에서 함수 컴포넌트를 export 한다.\r\n> default 또는 named export 방식을 사용한다.\r\n3. 컴포넌트를 사용할 파일에서 import 한다.\r\n> 적절한 방식을 선택해서 default 또는 named로 import 한다.\r\n\r\n```js\r\nimport Gallery from './Gallery.js';\r\n\r\ne"},{"title":"Writing Markup with JSX","author":"Jay.J","date":"2024-06-17T00:00:00.000Z","categories":["javascript","ReactJs"],"tags":["javascript","ReactJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/react.png","url":"/post/2024-06-17-1_3_Writing_Markup_with_JSX","con":"---\r\n\r\n<br>\r\n\r\n## Writing Markup with JSX\r\n> 첫번째 컴포넌트\r\n<br>\r\n\r\n### JSX: JavaScript에 마크업 넣기\r\n원래의 Web은 HTML, CSS, JavaScript를 기반으로써,<br>\r\nHTML로 내용을, CSS로 디자인을, JavaScript로 로직을 작성하면서 각각 별도의 파일로 관리했다.<br>\r\n<br>\r\n그러나 Web이 더욱 인터랙티브해지면서 로직이 내용을 결정하는 경우가 많아졌고, 그래서 JavaScript가 HTML을 담당하게 되었다 !<br>\r\n이것이 바로 React에서 <b>렌더링 로직과 마크업이 같은 위치(컴포넌트)에 함께 있게 된 이유</b>이다. \r\n<br>\r\n로직과 마크업이 공존하면 서로 싱크를 맞추기가 수월하다.<br>\r\n그리고 각 컨포넌트의 렌더링 로직/html 을 분리해서 관리 할 수 있어서 서로 관여를 없앨 수 있다.<br>\r\nReact 컴포넌트는 JSX라는 확장된 문법을 사용하여 마크업을 나타낸"},{"title":"Render_and_Commit","author":"Jay.J","date":"2024-06-17T00:00:00.000Z","categories":["javascript","ReactJs"],"tags":["javascript","ReactJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/react.png","url":"/post/2024-06-17-1_4_JavaScript_in_JSX_with_Curly_Braces","con":"---\r\n\r\n<br>\r\n\r\n## Render_and_Commit\r\n> 렌더링 그리고 커밋\r\n<br>\r\n\r\n### 따옴표로 문자열 전달하기\r\n<br>\r\n1. 문자열 어트리뷰트를 JSX에 전달하려면 작은따옴표나 큰따옴표로 묶어야 한다.<br>\r\n\r\n```js\r\nexport default function Avatar() {\r\n  return (\r\n    <img\r\n      className=\"avatar\"\r\n      src=\"https://i.imgur.com/7vQD0fPs.jpg\"\r\n      alt=\"Gregorio Y. Zara\"\r\n    />\r\n  );\r\n}\r\n```\r\n\r\n<br>\r\n2. 어트리뷰트를 JSX에 동적으로 전달하려면 중괄호로 묶어야 한다.<br>\r\n\r\n```js\r\nexport default function Avatar() {\r\n  const avatar = 'https://i.imgur.com/7vQD0fPs.jpg';\r\n  const description = '"},{"title":"Passing Props to a Component","author":"Jay.J","date":"2024-06-17T00:00:00.000Z","categories":["javascript","ReactJs"],"tags":["javascript","ReactJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/react.png","url":"/post/2024-06-17-1_5_Passing_Props_to_a_Component","con":"---\r\n\r\n<br>\r\n\r\n## Passing Props to a Component\r\n> 컴포넌트에 props 전달하기\r\n<br>\r\n\r\n### 친숙한 props\r\nprops는 JSX 태그에 전달하는 정보이다.<br>\r\n예를 들어, className, src, alt, width, height는 ```<img>``` 태그에 전달할 수 있다.\r\n\r\n```js\r\nfunction Avatar() {\r\n  return (\r\n    <img\r\n      className=\"avatar\"\r\n      src=\"https://i.imgur.com/1bX5QH6.jpg\"\r\n      alt=\"Lin Lanying\"\r\n      width={100}\r\n      height={100}\r\n    />\r\n  );\r\n}\r\n\r\nexport default function Profile() {\r\n  return (\r\n    <Avatar />\r\n  );\r\n}\r\n```\r\n\r\n### 컴포넌트에 props 전달하기 "},{"title":"Conditional Rendering","author":"Jay.J","date":"2024-06-17T00:00:00.000Z","categories":["javascript","ReactJs"],"tags":["javascript","ReactJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/react.png","url":"/post/2024-06-17-1_6_Conditional_Rendering","con":"---\r\n\r\n<br>\r\n\r\n## Conditional Rendering\r\n> 조건부 렌더링\r\n<br>\r\n\r\n### 조건부로 JSX 반환하기\r\n```js\r\nfunction Item({ name, isPacked }) {\r\n  if (isPacked) {\r\n    return <li className=\"item\">{name} ✔</li>;\r\n  }\r\n  return <li className=\"item\">{name}</li>;\r\n}\r\n\r\nexport default function PackingList() {\r\n  return (\r\n    <section>\r\n      <h1>Sally Ride's Packing List</h1>\r\n      <ul>\r\n        <Item \r\n          isPacked={true} \r\n          name=\"Space suit\" \r\n        />\r\n        <Item \r\n          isPacked={true} \r\n    "},{"title":"Rendering Lists","author":"Jay.J","date":"2024-06-17T00:00:00.000Z","categories":["javascript","ReactJs"],"tags":["javascript","ReactJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/react.png","url":"/post/2024-06-18-1_7_Rendering_Lists","con":"---\r\n\r\n<br>\r\n\r\n## Rendering Lists\r\n> 리스트 렌더링\r\n<br>\r\n\r\n### 배열을 데이터로 렌더링하기\r\n\r\n#### 1. 데이터를 배열로 만든다.\r\n```js\r\nconst people = [\r\n  'Creola Katherine Johnson: mathematician',\r\n  'Mario José Molina-Pasquel Henríquez: chemist',\r\n  'Mohammad Abdus Salam: physicist',\r\n  'Percy Lavon Julian: chemist',\r\n  'Subrahmanyan Chandrasekhar: astrophysicist'\r\n];\r\n```\r\n\r\n#### 2. people의 요소를 새로운 JSX 노드 배열인 listItems에 매핑한다.\r\n```js\r\nconst listItems = people.map(person => <li>{person}</li>);\r\n```\r\n\r\n#### 3. ```<ul>```로 래"},{"title":"Keeping Components Pure","author":"Jay.J","date":"2024-06-17T00:00:00.000Z","categories":["javascript","ReactJs"],"tags":["javascript","ReactJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/react.png","url":"/post/2024-06-18-1_8_Keeping_Components_Pure","con":"---\r\n\r\n<br>\r\n\r\n## Keeping Components Pure\r\n> 컴포넌트 순수하게 유지하기\r\n<br>\r\n\r\n### 순수성: 공식으로서의 컴포넌트\r\n컴퓨터 과학에서(특히 함수형 프로그래밍의 세계에서는) 순수 함수는 다음과 같은 특징을 지니고 있는 함수이다.\r\n1. 자신의 일에 집중합니다. 함수가 호출되기 전에 존재했던 어떤 객체나 변수는 변경하지 않는다.\r\n2. 같은 입력, 같은 출력 같은 입력이 주어졌다면 순수함수는 같은 결과를 반환해야 한다.\r\n\r\n```js\r\n// 예시\r\nfunction double(number) {\r\n  return 2 * number;\r\n}\r\n```\r\n> React는 이러한 컨셉 기반에 설계되었다.<br>\r\n> React는 작성되는 모든 컴포넌트가 순수 함수일 거라 가정한다.\r\n<br>\r\n\r\n### 사이드 이펙트: 의도하지(않은) 결과 \r\nReact의 렌더링 과정은 항상 순수해야 한다.<br/>\r\n컴포넌트는 <b>렌더링하기 전에 존재했던 객체나"},{"title":"Understanding Your UI as a Tree","author":"Jay.J","date":"2024-06-17T00:00:00.000Z","categories":["javascript","ReactJs"],"tags":["javascript","ReactJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/react.png","url":"/post/2024-06-18-1_9_Understanding_Your_UI_as_a_Tree","con":"---\r\n\r\n<br>\r\n\r\n## Understanding Your UI as a Tree\r\n> 트리로서 UI 이해하기\r\n<br>\r\n\r\n### 트리로서의 UI\r\n데이터와 UI를 그릴때 트리구조가 많이 사용된다.\r\n- html → DOM\r\n- css → CSSOM \r\n\r\n모바일도 마찬가지로 계층구조를 트리로 만들어준다.\r\n\r\n<br>\r\n\r\n<img src=\"/assets/img/react/ui_tree.png\" alt=\"\" style=\"max-width:500px\">\r\n\r\n> React는 컴포넌트로부터 UI 트리를 생성한다.<br>\r\n> 위 예제 그림은 UI 트리는 DOM을 렌더링하는 데 사용됩니다.\r\n\r\n<br>\r\n브라우저와 모바일 플랫폼처럼 React도 React 앱의 컴포넌트 간의 관계를 관리하고 모델링하기 위해 트리 구조를 사용한다. <br>\r\n<b>트리는 데이터가 흐르는 방식과 렌더링 및 앱 크기를 최적화하는 방법을 이해하는 데 유용한 도구</b>이다.\r\n\r\n<br>\r\n\r\n##"},{"title":"React의 상태관리 - Zustand","author":"Jay.J","date":"2023-12-10T00:00:00.000Z","categories":["javascript","ReactJs"],"tags":["javascript","ReactJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/react.png","url":"/post/2023-12-10-zustand","con":"---\r\n\r\n<br>\r\n\r\n## React의 상태관리 - Zustand\r\nReact에서 상태란 동적인 데이터이다.<br>\r\n동적인 데이터는 <b>데이터의 값이 변경되면 렌더링에 영향을 주는 값</b>이라고 할 수 있다.<br>\r\n<br>\r\n너무 잦은 상태의 변화는 잦은 렌더링이 이루어지기에 전체적인 성능저하가 일어날 수 있다.<br>\r\n또한 리액트는 단방향 바인딩으로, 부모 컴포넌트에서 자식 컴포넌트로만 state를 props로 전달할 수 있고, 반대로 부모 컴포넌트로 props를 직접 전달할 수는 없다.<br>\r\n자식 컴포넌트에서 부모 컴포넌트에 있는 state를 변경하려면 setState를 props로 넘겨줘야 한다.<br>\r\n코드 자체가 복잡해지고 상호 의존성이 많아져서 효율적이지 못하다.<br>\r\n<br>\r\n따라서 두 가지를 지키기 위하여 <b>상태관리</b>가 필요하다.\r\n1. 데이터가 바뀌어도 페이지가 렌더링 되지 않게 하기 위해\r\n2. 상태(state)들이 복잡하게 얽혀"},{"title":"FireBase - 데이터베이스 이용하기","author":"Jay.J","date":"2023-12-10T00:00:00.000Z","categories":["javascript","ReactJs","Firebase"],"tags":["javascript","ReactJs","Firebase"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/firebase.png","url":"/post/2023-12-22-firebase","con":"---\r\n\r\n<br>\r\n\r\n## FireBase - 데이터베이스 이용하기\r\n\r\n<br>\r\n\r\n### FireBase 란?\r\nFireBase는 2014년도에 구글에서 인수한 모바일, 웹 애플리케이션 개발 플랫폼이다.\r\nFirebase는 데이터베이스, 인증, 스토리지, 원격 구성, 푸시 알람 등다양한 기능을 제공한다.\r\n\r\n<br>\r\n\r\n### FireBase 시작하기\r\n1. <a href=\"https://firebase.google.com/?hl=ko\" target=\"_blank\">공식사이트</a>에 일단 가입해야한다.\r\n2. 공식사이트에서 로그인 후 console로 이동한다.<br>\r\n<img src=\"/assets/img/firebase/firebase.png\" style=\"max-width:500px\" alt=\"\">\r\n\r\n3. 새 프로젝트를 추가한다.<br>\r\n<img src=\"/assets/img/firebase/firebase2.png\" style=\"max-width:500p"},{"title":"Icon Font란?","author":"Jay.J","date":"2023-10-30T00:00:00.000Z","categories":["html","css"],"tags":["html","css"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/css.png","url":"/post/2023-10-30-iconFont","con":"---\r\n\r\n<br>\r\n\r\n## Icon Font란?\r\n아이콘 폰트(icon font)란 문자/숫자 대신 아이콘(icon)과 심볼(symbol)로 채워진 \"폰트 파일\"이다.\r\n\r\n### Icon Font 장점\r\n- Icon font는 vector 이미지로, image 보다 훨씬 가볍다.\r\n- 글자 색상, 글자 크기 등 일반 텍스트와 같은 방식으로 CSS를 통해 간편하게 스타일링할 수 있다.\r\n\r\n### Icon Font 단점\r\n- 아이콘의 컬러로 한 가지 색상 또는 그라데이션만 설정할 수 있다. (일반 이미지처럼 부분마다 컬러 지정X)\r\n- 몇몇 스크린 리더는 Icon Font가 무엇인지 읽지 못한다.\r\n- 아이콘 폰트가 로드되지 않는 경우, 적당히 대체할 것이 없다.\r\n\r\n<br />\r\n\r\n## Icon Font 사용법\r\nSVG 이미지를 Icon Font로 변환해주는 사이트를 이용해야한다.\r\n> <a href=\"https://icomoon.io/app/#/select\" target"},{"title":"React 프레임워크 - Next.js","author":"Jay.J","date":"2023-09-12T00:00:00.000Z","categories":["javascript","ReactJs","NextJs"],"tags":["javascript","ReactJs","NextJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/nextjs.png","url":"/post/2023-09-12-NextJs","con":"---\r\n\r\n<br>\r\n\r\nNext.js는 React 라이브러리의 프레임워크이다.<br>\r\nPre-Rendering, 서버 사이드 렌더링(Server Side Rendering - SSR), App Router, Code Splitting  같은 다양하고 풍부한 기능을 제공한다.<br>\r\n<br>\r\nReact는 클라이언트 사이드 렌더링(Client Side Rendering - CSR)으로 Search Engine Optimization(SEO)의 대응이 미흡하다.<br>\r\n그래서 <b>SEO를 대응하기 위해서 SSR 을 지원하는 Next.js를 사용</b>한다고 많은 포스트에서 작성하고 있다.\r\n\r\n## Next.js가 제공하는 기능들.\r\n\r\n### Pre-Rendering\r\n\r\n기본적으로 Next.js는 Static-Site Generate(SSG)와 Server Side Rendering(SSR)을 제공한다.<br>\r\n<br>\r\n두 가지 렌더링 호출 방식의 공통점은 <b>HTM"},{"title":"Astro.js","author":"Jay.J","date":"2023-08-25T00:00:00.000Z","categories":["astroJs"],"tags":["astroJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/astrojs.png","url":"/post/2023-08-25-AstroJs","con":"---\r\n\r\n<br>\r\n\r\n최근 회사에서 Astro.js를 도입하였다.<br>\r\nAstro.js가 무엇인 지 앞서 왜 Astro.js를 도입하려고 했는 지 적으려고 한다.\r\n\r\n<br>\r\n\r\n<hr>\r\n<br>\r\n\r\n## 도입 전 시스템\r\n기존의 개발 도구(Grunt)는 빌드의 속도가 느려 Front End 개발 속도를 저하시키고, 또한 퍼블리싱(HTML, CSS)와 운영(JSP) 소스를 따로 관리하여 버전 관리의 어려움이 있었다.<br>\r\n<br>\r\n또한 퍼블리싱과 운영 담당자가 다름으로 오류 발생 시 원인 분석 시간이 늘어나고, 책임 소재가 불명확하며, 간단한 수정 사항(HTML, CSS)도 퍼블리싱(Front End), 운영(Back End) 담당자가 각각 투입되어 불필요한 인력 자원 사용하는 구조적인 문제점이 있었다.<br>\r\n\r\n<img src=\"/assets/img/astro/astro_system.png\" style=\"max-width:500px\" alt=\"\">\r\n\r\n#"},{"title":"Google Sheets API","author":"Jay.J","date":"2023-07-20T00:00:00.000Z","categories":["javascript"],"tags":["javascript"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/javaScript.png","url":"/post/2023-07-20-googleSheetsAPI","con":"---\r\n\r\n<br>\r\n\r\n최근 회사 업무로 Google Sheets API를 사용하였다.<br>\r\n이전까지 데이터를 관리, 연동 개발은 DateBase(DB)만 생각하었는데,<br>\r\nDB구축을 하지 않고 간단하게 데이터를 저장하고 연동하여 활용할 수 있었다.<br>\r\n<br>\r\n개인적으로 간단하고 편하게 사용할 수 있었기에 정보를 공유하고 작성한다.\r\n\r\n<br>\r\n\r\n<hr>\r\n<br>\r\n\r\n## Google Sheets API\r\nGoogle Sheets API를 사용하기 위해서는 Google Sheets를 생성해줘야한다.<br>\r\n\r\n<br>\r\n\r\n### Google Sheets 생성하기.\r\n\r\n<br>\r\n\r\n1. Google 메인 화면에서 상단의 메뉴 > 드라이브를 눌러준다.\r\n\r\n<img src=\"/assets/img/javascript/google_sheet_creat.png\" alt=\"\">\r\n\r\n<br>\r\n\r\n2. 본인의 드라이브로 접속이 되었다면, 좌측 상단에 신규 "},{"title":"React_MUI","author":"Jay.J","date":"2023-07-10T00:00:00.000Z","categories":["javascript","ReactJs","MUI","css"],"tags":["javascript","ReactJs","MUI","css"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/mui.png","url":"/post/2023-07-10-React_MUI","con":"---\r\n\r\n<br>\r\n\r\n## MUI란\r\nMUI(Material UI)는 Material Design을 구현해놓은 라이브러리이다.<br>\r\n이 라이브러리를 이용하면 material 디자인 스타일이 적용된 UI를 매우 쉽게 구현할 수 있다. <br>\r\n<br>\r\n\r\n### Material Design이란?\r\n구글은 모바일과 데스크탑 그리고 그 외 다양한 디바이스들을 아우르는 하나의 일관된 디자인 가이드라인을 공개하였는데, 이것이 바로 <b>Material Design</b>이다.<br>\r\n<br>\r\n머티리얼 디자인은 질감이 느껴지는 표면 (tactile surfaces) 과 대담하고 선명한 그래픽 디자인 (bold graphic design), 그리고 아름답고 직관적인 사용자 경험을 위한 자연스러운 애니메이션을 특징으로 한다.\r\n\r\n<br>\r\n\r\n## MUI 설치하기\r\nMUI는 npm, yarn 등으로 설치할 수 있다.\r\n\r\n```js\r\n// npm\r\nnpm install @mui/"},{"title":"React란?","author":"Jay.J","date":"2023-03-07T00:00:00.000Z","categories":["javascript","ReactJs"],"tags":["javascript","ReactJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/react.png","url":"/post/2023-03-07-Reactjs","con":"---\r\n\r\n<br>\r\n\r\n## React.js 란 무엇인가?\r\nReact.js의 공식문서에서는 <b>'사용자 인터페이스를 만들기 위한 JavaScript 라이브러리'</b> 라고 설명하고 있다.<br>\r\n즉, 보여지는 화면을 만드는 자바스크립트 프레임워크 중의 하나이다.<br>\r\n\r\n> <a href=\"https://ko.legacy.reactjs.org/\" target=\"_blank\">React.js 공식사이트</a>\r\n\r\n<br>\r\n\r\n## 장점 및 특징\r\n1. Component 기반 구조\r\n2. Data Flow\r\n3. Virtual Dom\r\n4. JSX\r\n\r\n<Br>\r\n\r\n### Component 기반 구조\r\n\r\nVue.js 에서 한번 설명했던 구조이다.<br>\r\nDOM을 작은 단위로 쪼개어 개발하는 방식으로 유지보수와 재사용성이 높다.<br>\r\n<br>\r\n작은 단위로 쪼개져 있는 Dom 하나를 Component라 부르며, 독립된 Component들을 조립해 화면을 구성한다"},{"title":"Javascript and CSS Animation","author":"Jay.J","date":"2023-01-15T00:00:00.000Z","categories":["css"],"tags":["css"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/css.png","url":"/post/2023-01-15-jsAndCssAnimation","con":"---\r\n\r\n<br>\r\n\r\n브라우저에서 애니메이션 효과를 사용하기 위해서는 두 가지의 방법을 사용할 수 있습니다. <br>\r\nCSS의 <b style=\"color:skyblue\">transition / animation</b> 속성과 <br>\r\nJavascript의 <b style=\"color:#D7DF01\">setInterval / requestAnimationFrame </b> 함수를 사용할 수 있습니다.<br>\r\n<br>\r\n<br>\r\n\r\n<hr>\r\n<br>\r\n\r\n## CSS 애니메이션\r\n\r\nCSS 애니메이션은 Javascript 애니메이션보다 좀 더 간단한 애니메이션을 구현하고 처리하는데 사용합니다.<br>\r\ntransform의 translate를 사용하여 애니메이션을 구현하면 Javascript로 애니메이션을 구현하는 것보다 성능을 개선할 수 있습니다.<br>\r\nJavascript의 경우 top, left등의 속성 값을 변화시키면 랜더링 과정에서 <b style=\"color:"},{"title":"느낌표 두개 연산자 - Double Exclamation Marks Operator","author":"Jay.J","date":"2022-12-12T00:00:00.000Z","categories":["javascript"],"tags":["javascript"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/javaScript.png","url":"/post/2022-12-12-doble_ExclamationMarks","con":"---\r\n\r\n<br>\r\n\r\n라이브러리를 사용하기 위하여 분석하다가 !! 연산자를 사용한 것을 본 적이 있다.<br>\r\n어떤 동작을 하는 연산자인지 검색해보고 알게된 내용을 정리하려고 한다.\r\n\r\n<br>\r\n\r\n## NOT 연산자인 (느낌표) and 느낌표 두개(!!) 연산자\r\n\r\n```js\r\nconsole.log(\"str\")      // \"str\"\r\nconsole.log(!(\"str\"))   //false\r\nconsole.log(!!(\"str\"))  //true\r\n\r\nconsole.log(\"\")         //\"\"\r\nconsole.log(!(\"\"))      //true\r\nconsole.log(!!(\"\"))     //false\r\n\r\nconsole.log(true)       //true\r\nconsole.log(!true)      //false\r\nconsole.log(!!true)     //true\r\n\r\nconsole.log(false)      //false\r\nconsol"},{"title":"클로져란 ?","author":"Jay.J","date":"2022-11-10T00:00:00.000Z","categories":["javascript"],"tags":["javascript"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/javaScript.png","url":"/post/2022-11-10-closure","con":"---\r\n\r\n<br>\r\n\r\n## 클로져란\r\n\r\n클로저는 함수와 함수가 선언된 어휘적 환경의 조합이다.<br>\r\n클로저를 이해하려면 자바스크립트가 어떻게 변수의 유효범위를 지정하는지(Lexical scoping)를 먼저 이해해야 한다.\r\n> MDN 출처\r\n\r\n<br>\r\n\r\n## 스코프\r\n\r\n자바스크립트의 스코프는 범위를 뜻한다.<br>\r\n\r\n```js\r\nfunction scope_a(){\r\n\tconst consoleData = 'a';\r\n\r\n\tfunction scope_b(){\r\n\t\tconst consoleData = 'b';\r\n\r\n\t\tconsole.log(consoleData); // b\r\n\t}\r\n\r\n\tscope_b();\r\n\tconsole.log(consoleData); // a\r\n}\r\n\r\nscope_a();\r\n```\r\n\r\n<br>\r\n\r\nscope_a 함수에서 consoleData 변수에 값 'a'를 넣었고,<br>\r\nscope_b 함수에서 consoleData 변수에 값 'b'를 "},{"title":"Web Component","author":"Jay.J","date":"2022-10-21T00:00:00.000Z","categories":["html","javascript"],"tags":["html","javascript"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/html.png","url":"/post/2022-10-21-WebComponent","con":"---\r\n\r\n<br>\r\n\r\n최근 어플리케이션 시장이 점점 커지고 복잡해지면서 컴포넌트 기반의 프레임워크들이 등장하였다.<br>\r\n복잡한 소프트웨어들을 간단한 부분들로 나눠서 개발하는 방식으로 대표적으로 React, Vue, Angluar등의 자바스크립트 프레임워크들이 있다<br>\r\n\r\n최근에는 자바스크립트의 프레임워크이 인기가 많아지면서 관심을 받고 있는데<br>\r\n그 기반인 웹 컴포넌트에 대해서 알아보려고 한다.\r\n\r\n## Web Component란\r\n\r\n컴포넌트(Component)란 기능을 다른 코드로부터 분리된 재사용이 가능한 독립적인 모듈을 뜻한다.<br>\r\n컴포넌트 기반 프로그래밍을 하면 마치 레고 블록처럼 이미 만들어진 컴포넌들을 조합하여 화면을 구성할 수 있다.<br>\r\n\r\n<img src=\"/assets/img/html/webComponent.jpg\" alt=\"\">\r\n\r\n<br>\r\n웹 컴포넌트는 이러한 컴포넌트 기반 프로그래밍을 웹에서도 적용할 수 있도록 W3C에서 새"},{"title":"Vue에서 사용하는 SEO","author":"Jay.J","date":"2022-09-04T00:00:00.000Z","categories":["html","VueJs"],"tags":["html","vue.js"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/vuejs.png","url":"/post/2022-09-04-SeoUsedInVue","con":"---\r\n\r\n<br>\r\n\r\n최근 들어 SPA로 구현된 사이트가 증가하고 있다.<br>\r\n하지만 SPA 검색엔진에 잘 노출이 되지 않아 사이트에 많은 사람들이 방문하지 못하는 문제들이 생기고 있다.<br>\r\nSPA에서의 SEO는 어떻게 해결하는 지 포스팅하려고 한다.\r\n\r\n## MPA와 SPA의 차이\r\n\r\nSEO를 어떻게 해결하는 방법이 있는 지 알아보기 전에, MPA와 SPA에 대해서 알아야한다.\r\n\r\n## MPA\r\n\r\nMPA(Multiple Page Application)는 여러 개(Multiple)의 Page로 구성된 Application이다.<br>\r\n전통적인 방식으로 페이지를 요청할 때마다 정적 리소스가 다운로드된다. <b>매번 전체 페이지가 다시 렌더링</b> 된다.<br>\r\nMPA를 SSR(Server Side Rendering) 방식으로 렌더링한다고 말한다.<br>\r\n<br>\r\n\r\n<img src=\"/assets/img/html/MPA.webp\" alt=\"\">\r\n> MP"},{"title":"'적응형 웹'과 '반응형 웹'","author":"Jay.J","date":"2022-08-16T00:00:00.000Z","categories":["html"],"tags":["html"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/html.png","url":"/post/2022-08-16-AdaptiveWebAndResponsiveWeb","con":"---\r\n\r\n<br>\r\n\r\n## '적응형 웹'과 '반응형 웹' 이란?\r\n\r\n1. <b>적응형 웹 : </b> 각각의 디바이스 별로 독립적인 템플릿(Templete)으로 랜딩되는 웹.\r\n2. <b>반응형 웹 : </b> 하나의 템플릿(Templete)로 모바일 , 태블릿, 데스크탑 모든 기기에 대응할 수 있는 웹.\r\n\r\n<br>\r\n<hr>\r\n<br>\r\n\r\n## 적응형 웹 ( Adaptive Web )\r\n\r\n<b>'각각의 디바이스 별로 독립적인 템플릿(Templete)으로 랜딩되는 웹'</b>\r\n<br>\r\n각각의 디바이스별(Pc, Mobile)로 템플릿을 제작해야하며, 사용자가 url로 접속시 어떤 디바이스로 접속했는지 파악하여 디바이스별로 랜딩시켜준다.<br>\r\n예를들어 PC로 접속하면 PC URL로 랜딩되고, Mobile로 접속시 Mobile URL을 랜딩시켜준다.\r\n\r\n<img src=\"/assets/img/html/Adaptive.gif\" alt=\"\" style=\"max-widt"},{"title":"브라우저의 동작원리","author":"Jay.J","date":"2022-07-14T00:00:00.000Z","categories":["html"],"tags":["html"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/html.png","url":"/post/2022-07-14-DOMRendering","con":"---\r\n\r\n<br>\r\n\r\n최근 HTML 파일은 어떻게 브라우저에 그려지는지 질문을 받은 적이 있다.<br>\r\nVue를 공부하면서 브라우저의 동작원리에 대해서 잠깐 다룬적이 있었으나,<br>\r\n정확히 알고 있지 않아서 답변을 할 수 없었고 이번 기회에 브라우저 렌더링 과정에 대해서 공부하고 정리해보려고 한다.\r\n\r\n## 브라우저 렌더링 동작 과정\r\n\r\n주소창에 url을 입력하고 접속하였을 때 브라우저는 해당 페이지에 대한 리소스를 서버에 요청한다.<br>\r\n그 이후 브라우저의 렌더링 동작 과정은 5가지로 나눌 수 있다.\r\n\r\n1. Parsing\r\n2. Render Tree\r\n3. Layout\r\n4. Paint\r\n5. Composite\r\n\r\n<br>\r\n\r\n<img src=\"/assets/img/vue/webkitflow.png\" alt=\"\">\r\n> 브라우저의 동작 순서\r\n\r\n### 1. Parsing\r\n\r\n서버에서 받아온 리소스(HTML, CSS)의 문자는 브라우저가 바로 인식하지 못"},{"title":"Box Model","author":"Jay.J","date":"2022-05-24T00:00:00.000Z","categories":["html","css"],"tags":["html","css"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/html.png","url":"/post/2022-05-24-BoxModel","con":"---\r\n\r\n<br>\r\n\r\n## Box Model이란?\r\n\r\n모든 HTML 요소는 박스(box) 모양으로 구성되며, 이것을 박스 모델(box model)이라고 부른다.\r\n박스 모델은 HTML 요소를 패딩(padding), 테두리(border), 마진(margin), 그리고 내용(content)으로 구분한다.\r\n\r\n<br>\r\n\r\n## 웹 브라우저에서의 Box Model은?\r\n\r\n웹 브라우저에서의 Box Model은 content-box 와 border-box 기준이 있다.\r\ncontent-box는 콘텐츠 영역을 기준으로 크기를 정하며 border-box는 테두리 영역을 기준으로 크기를 정한다.\r\nCSS의 속성을 통하여 Box Model의 기준을 정할 수 있다.\r\n\r\n<br>\r\n\r\n## CSS 문법\r\n\r\n```css\r\nbox-sizing: content-box | border-box | initial | inherit\r\n```\r\n<br>\r\n\r\n- content-box : 콘텐트 영역을 "},{"title":"DOCTYPE 이란?","author":"Jay.J","date":"2022-05-03T00:00:00.000Z","categories":["html"],"tags":["html"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/html.png","url":"/post/2022-05-06-DOCTYPE","con":"---\r\n\r\n<br>\r\n\r\n## DOCTYPE 란?\r\n웹 문서에서 DTD(문서 유형 정의)를 통해서 현재 문서가 어떤 버전으로 기술되었는지 브라우저에 전달하는데 이것을 DOCTYPE 선언이라고 한다.<br>\r\nDTD(Document Type Definition)는 XHTML, HTML, HTML5 세 가지 유형이 있으며, 선언된 문서 형식에 따라 마크업 속성을 처리하는 기준이 정해지고, 유효성 검사에 활용된다.\r\n\r\n<br>\r\n\r\n## DOCTYPE 선언의 목적\r\n\r\n웹 브라우저는 두 가지 렌더링 모드를 가지고 있는데 쿼크모드(Quirks mode)와 표준모드(Standard mode)이다.<br>\r\n브라우저가 출력하고자 하는 문서가 최신이라면 표준모드로 렌더링하며, 오래된 문서라면 쿼크 모드로 렌더링 하게 된다.<br>\r\n<br>\r\n이 과정에서 어떤 유형의 문서인지 정의해주는 것이 DOCTYPE 선언이다.\r\nDOCTYPE을 생략할 경우, 브라우저마다 상이하게 보여지거나(크로스 브라"},{"title":"CSS의 BEM을 사용해보자","author":"Jay.J","date":"2022-04-12T00:00:00.000Z","categories":["css"],"tags":["css"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/css.png","url":"/post/2022-04-12-BEM","con":"---\r\n\r\n<br>\r\n\r\n## BEM이란?\r\n\r\nBEM은 CSS 네이밍 방법론 중 하나이다.<br>\r\nHTML의 요소를 <b>Block</b>, <b>Element</b>, <b>Modifier</b> 세가지로 구분하여 클래스명을 작명하는 방법이다.\r\n\r\n<br>\r\n\r\n## BEM의 장점\r\n\r\n- 목적과 기능을 직관적으로 알 수 있다.\r\n- 재사용성이 높다.\r\n- CSS만으로 구조를 알 수 있다.\r\n\r\n<br>\r\n\r\n## Block\r\n\r\n### 의미\r\nBlock 은 단독으로 사용할 수 있는 <b>독립적인 요소</b>이다.<br>\r\n<b>재사용성이 가능</b>하고 높은 요소이다.<br>\r\n재사용을 위해서 Block 요소에는 <b>Padding과 Margin 속성을 적용하지 않는다.</b>\r\n\r\n### HTML 구조\r\n\r\n```\r\n*** HTML ***\r\n\r\n<header>\r\n    <div>\r\n        Logo\r\n    </div>\r\n\r\n    <nav>\r\n        Nav"},{"title":"CSS Flex","author":"Jay.J","date":"2022-03-02T00:00:00.000Z","categories":["css"],"tags":["css"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/css.png","url":"/post/2022-03-02-flex","con":"---\r\n\r\n<br>\r\n\r\nflex 는 레이아웃 구조를 잡을 수 있는 CSS 속성 중 하나이다.<br>\r\n컨테이너가 차지하는 공간에 맞춰서 아이템들이 유연하게 조절되기 때문에 레이아웃을 보다 쉽게 구현할 수 있다.<br>\r\n<br>\r\nInternet Explorer(이하 IE) 점유율이 높고 하위 버전까지 맞춰야 할 예전에는 하위 버전까지 지원하지 않아 잘 사용되지않았지만,<br> 현재 IE의 점유율이 낮아지면서 너무 낮은 버전의 IE 브라우저는 안맞추는 추세로 프로젝트가 진행되면서 많이 사용되었다.\r\n\r\n\r\n## 구성\r\n\r\n<img src=\"/assets/img/css/flex_container.png\" alt=\"\">\r\n\r\nflex는 부모 요소인 flex container과 자식 요소인 flex item으로 구성되어 있다.\r\n\r\n```\r\n*** HTML *** \r\n<div class=\"flex_container\">\r\n    <div class=\"flex_item\">Item 1</d"},{"title":"Git Fetch","author":"Jay.J","date":"2022-01-23T00:00:00.000Z","categories":["Git"],"tags":["Git"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/git.png","url":"/post/2022-01-23-GitFetch","con":"---\r\n\r\n<br>\r\n\r\n이전 Git 도입에 대한 포스팅을 작성하고 Git을 사용하면서 commit, pull, push, merge 등의 자주 사용하는 명령어만 포스팅하고 사용하였다.<br>\r\n기존에 설명한 명령어 외에 Fetch에 대해서 포스팅하려고 한다.\r\n\r\n## Fetch\r\n\r\n원격 저장소에 저장 되어있는 소스를 로컬 저장소로 가져오는 명령어이다.<br>\r\n<br>\r\n원격 저장소에서 소스를 가져오는 명령어는 Pull도 있다.<br>\r\nPull과 Fetch의 차이는 병합(Merge)에 있다.\r\n\r\n- <b>Pull : </b>원격 저장소에서 소스를 가져와서 자동으로 병합한다.\r\n- <b>Fetch : </b>원격 저장소에서 소스를 가져오기만 한다.\r\n\r\n<br>\r\n\r\nPull의 경우 자동으로 병합해주기 때문에 어떤 내용이 병합되었는 지 스스로 찾아서 확인해야한다.<br>\r\nFetch의 경우 소스만 가져오기 때문에 변경된 내용을 한번에 확인할 수 있다.<br>\r\n하지만 직접 "},{"title":"Git 도입과 브랜치전략","author":"Jay.J","date":"2022-01-12T00:00:00.000Z","categories":["Git"],"tags":["Git"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/git.png","url":"/post/2022-01-12-GitIntroduction","con":"---\r\n\r\n<br>\r\n\r\n## Git 도입과 브랜치전략\r\n\r\n사내에 소스 형상관리를 하고 있지않아, 소스가 날아가거나 백업파일을 만들어서 불필요한 용량을 차지한다거나 크고 작은 일들이 지속적으로 발생하였다.<br>\r\n그런 일들을 방지 및 해결하고자 Git을 도입하여 형상관리를 하기로 했다.\r\n\r\n- 1. Git 도입하기.\r\n- 2. Git 브런치전략.\r\n- 3. Git 도입 전과 후.\r\n\r\n<br>\r\n\r\n## 1. Git 도입하기.\r\n어떤 플랫폼을 사용할 것인가에 대해서 무료로 사용하고 비공개로 소스를 관리하기 위하여 Gitlab을 선택하였다.<br>\r\n> <a href=\"https://about.gitlab.com/\" target=\"blank\">Gitlab 바로가기</a>\r\n\r\n<br>\r\n\r\n### 1-1. git이란.\r\n\r\n형상 관리 도구 중 하나로써, 파일의 버전을 관리하는 시스템이다.<br>\r\n> 같은 형상 관리 도구로는 SVN이 있다.<br>\r\n\r\nGit은 각각의 개발 P"},{"title":"CodeIgniter에 Vue 도입하기","author":"Jay.J","date":"2021-11-20T00:00:00.000Z","categories":["VueJs"],"tags":["javascript","vue.js"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/vuejs.png","url":"/post/2021-11-20-VueInCI","con":"---\r\n\r\n<br>\r\n\r\n## CodeIgniter에 Vue 도입하기\r\n\r\n업계에서 Javascript의 프레임워크를 많이 사용하고 있어, 개인의 발전과 회사의 발전을 위해서 Vue.js를 도입해보기로 했다.<br>\r\n이 포스터에서는 PHP Codeigniter 기반의 환경인 Codeigniter(이하 코드이그나이터)에서 Vue를 적용시키면서 고민했던 점과 어려웠던 점을 포스팅하고자 한다.<br>\r\n\r\n<br>\r\n\r\n## 1. 코드이그나이터 환경내에 Vue 프로젝트 시작하기\r\n\r\n코드이그나이터 환경에서 Vue 프로젝트 시작하는 방법은 기존 Vue 프로젝트 시작하는 방법과 다르지 않다.<br>\r\n코드이그나이터 Root 폴더에서 Vue프로젝트를 생성하면 된다.<br>\r\n\r\n> Vue 생성 방법은 본 포스터에선 다루지 않는다.<br>\r\n> <a href=\"/blog/posts/2021-03-14-VueCLI\">Vue 프로젝트 생성하기</a>\r\n\r\n#### root폴더\r\n\r\n<img sr"},{"title":"async 와 await","author":"Jay.J","date":"2021-08-10T00:00:00.000Z","categories":["javascript"],"tags":["javascript"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/javaScript.png","url":"/post/2021-08-10-asyncAndawait","con":"---\r\n\r\n<br>\r\n\r\n## async 와 await 란\r\n\r\nasync는 asynchronous의 약자로 비동기 방식이다.\r\nasync는 예전부터 많이 봤었다.\r\n\r\n스크립트를 호출할 때도 사용했었으며,\r\n\r\n```js\r\n<script type=\"text/javascript\" src=\"common/js/script2.js\" async></script>\r\n```\r\n> 스크립트는 비동기적으로 호출한다.<br>\r\n> <a href=\"/blog/posts/%2Fpost%2F2018-03-29-Where_do_you_place_the_JavaScript\" target=\"_blank\">'Where do you place the JavaScript?' 포스터</a>\r\n\r\nAjax 또한 Ajax(<b>Asynchronous</b> JavaScript and XML)의 약자로, ajax 옵션중 async옵션이 존재한다.\r\n\r\n\r\n```js\r\n$.ajax({\r\n    ...\r\n    async:"},{"title":"ES6의 Map Filter Reduce 함수들","author":"Jay.J","date":"2021-07-15T00:00:00.000Z","categories":["javascript"],"tags":["javascript"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/javaScript.png","url":"/post/2021-07-15-MapFilterReduceInES6","con":"---\r\n\r\n<br>\r\n\r\n## ES6의 Map Filter Reduce 함수들\r\n\r\nmap, filter, reduce 함수 모두 ES6에서 추가된 함수로써, 배열(Array)에서 결과를 도출하고자 할 때 사용된다.<br>\r\n기존의 for문을 이용하여 loop 돌면서 결과를 도출했던 방식보다 유용하고 간결하게 사용할 수 있을 것으로 생각하며,<br>\r\n3개의 함수를 알아보고 정리하려고 한다.\r\n\r\n<br>\r\n\r\n## Map\r\n\r\nmap() 메서드는 배열 내의 모든 요소 각각에 대하여 주어진 함수를 호출한 결과를 모아 새로운 배열을 반환한다.\r\n\r\n### 구문\r\n\r\n```js\r\narr.map(callback(currentValue[, index[, array]])[, thisArg])\r\n```\r\n\r\n### 사용법\r\n\r\n```js\r\nconst numbers = [1, 2, 3];\r\nconst doubles = numbers.map( (num) => num * 2 );\r\n\r\nconsol"},{"title":"SSR(서버사이드 렌더링)과 CSR(클라이언트 사이드 렌더링)","author":"Jay.J","date":"2021-06-26T00:00:00.000Z","categories":["HTTP"],"tags":["HTTP"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/http.png","url":"/post/2021-06-26-SSR","con":"---\r\n\r\n<br>\r\n\r\n## SSR\r\n\r\n인터넷을 사용하다 보면 내가 검색했던 키워드나 정보에 관련된 광고만 눈에 보인 적이 있을 것이다.<br>\r\n이는 기업에서 우리의 행동 정보를 저장하고 분석하여 활용하고 있기 때문이다.<br>\r\n> 개인 맞춤 광고를 하다보니 사생활 논란이 있어 현재는 개인 맞춤 광고는 중지 계획을 가지고 있다.<br>\r\n> \"2021년 3월 3일 - 내년 4월까지 자사 웹브라우저 크롬 사용자의 개인 정보가 담긴 ‘쿠키(사용자가 특정 웹사이트에 접속할 때 자동으로 생성되는 파일)’를 분석하는 사업을 완전히 중단\"\r\n\r\n즉, <b style=\"color:blue\">트래킹은 사용자의 행동 데이터를 수치로 나타내기 위해서 데이터를 수집하여 데이터 베이스에 저장하는 것</b>이다.<br>\r\n\r\n<br>\r\n\r\n## 트래킹 분석\r\n\r\n저장된 정보를 가지고 웹 사이트 관리자는 웹 분석을 한다.<br>\r\n분석을 통하여 사람들이 사이트를 사용하는 방법, 사람들이 좋아하는 것"},{"title":"웹 추적 기술 - 웹 트래킹(Tracking)","author":"Jay.J","date":"2021-06-05T00:00:00.000Z","categories":["HTTP"],"tags":["HTTP"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/http.png","url":"/post/2021-06-05-Tracking","con":"---\r\n\r\n<br>\r\n\r\n## 트래킹(Tracking)\r\n\r\n인터넷을 사용하다 보면 내가 검색했던 키워드나 정보에 관련된 광고만 눈에 보인 적이 있을 것이다.<br>\r\n이는 기업에서 우리의 행동 정보를 저장하고 분석하여 활용하고 있기 때문이다.<br>\r\n> 개인 맞춤 광고를 하다보니 사생활 논란이 있어 현재는 개인 맞춤 광고는 중지 계획을 가지고 있다.<br>\r\n> \"2021년 3월 3일 - 내년 4월까지 자사 웹브라우저 크롬 사용자의 개인 정보가 담긴 ‘쿠키(사용자가 특정 웹사이트에 접속할 때 자동으로 생성되는 파일)’를 분석하는 사업을 완전히 중단\"\r\n\r\n즉, <b style=\"color:blue\">트래킹은 사용자의 행동 데이터를 수치로 나타내기 위해서 데이터를 수집하여 데이터 베이스에 저장하는 것</b>이다.<br>\r\n\r\n<br>\r\n\r\n## 트래킹 분석\r\n\r\n저장된 정보를 가지고 웹 사이트 관리자는 웹 분석을 한다.<br>\r\n분석을 통하여 사람들이 사이트를 사용하는 방법, 사"},{"title":"Cookie와 Session의 차이는 무엇일까","author":"Jay.J","date":"2021-05-23T00:00:00.000Z","categories":["HTTP"],"tags":["javascript","HTTP"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/http.png","url":"/post/2021-05-23-CookieVsSeccion","con":"---\r\n\r\n<br>\r\n\r\n## 쿠키(Cookie)\r\n\r\n사용자가 어떠한 웹 사이트를 방문할 경우 사용자의 컴퓨터에 저장하는 작은 기록 정보 파일이다.<br>\r\n사용자가 따로 요청하지 않아도 브라우저가 Request시에 Request Header를 넣어서 자동으로 서버에 전송한다.<br>\r\n사용자의 상태 정보를 로컬에 저장했다가 필요시 정보를 참조하거나 재사용 한다.<br>\r\n사용자 인증이 유효한 시간을 명시할 수 있으며, 유효 시간이 정해지면 브라우저가 종료되어도 인증이 유지된다는 특징이 있다.\r\n\r\n### 쿠키의 구성 요소\r\n\r\n- 이름 : 각각의 쿠키를 구별하는 데 사용되는 이름\r\n- 값 : 쿠키의 이름과 관련된 값\r\n- 유효시간 : 쿠키의 유지시간\r\n- 도메인 : 쿠키를 전송할 도메인\r\n- 경로 : 쿠키를 전송할 요청 경로\r\n\r\n### 쿠키 특징\r\n\r\n- 이름, 값, 만료일(저장 기간 설정), 경로 정보로 구성되어 있다.\r\n- 사용자마다 총 300개의 쿠키를 저장할 수 있다."},{"title":"RESTful API 이란","author":"Jay.J","date":"2021-05-15T00:00:00.000Z","categories":["HTTP"],"tags":["HTTP"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/restapi.png","url":"/post/2021-05-15-RESTfulAPI","con":"---\r\n\r\n<br>\r\n\r\n## RESTful API란?\r\n\r\nREST를 기반 API를 의미합니다.<br>\r\nREST은 무엇인지, REST API는 무엇인지, RESTful API는 무엇인지 알아보려고합니다.\r\n\r\n<br>\r\n<hr>\r\n<br>\r\n\r\n## 1. RESTful API에서 REST 란?\r\n\r\nREST는 <span style=\"color:blue\">Representational State Transfer</span>의 약자로써 풀어서 설명하자면<br>\r\n<span style=\"color:red\">자원을 이름으로 구분해 해당 자원의 상태를 주고 받는 것</span>을 말한다.<br>\r\n<br>\r\n<b>웹에 존재하는 자원(이미지, 동영상, DB)에 대한 CRUD 요청을,<br>\r\n고유한 URI(Resource와 Method)로 표현하여 특정한 형태로 전달하는 방법이다.</b>\r\n> <b> CRUD : Create, Read, Update, Delete </b> <Br>\r\n> "},{"title":"통신을 위한 라이브러리, Axios","author":"Jay.J","date":"2021-05-02T00:00:00.000Z","categories":["VueJs","axios"],"tags":["javascript","axios","HTTP"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/axios.png","url":"/post/2021-05-01-Axios","con":"---\r\n\r\n<br>\r\n\r\n## &nbsp;\r\n\r\n<b>\"Axios는 브라우저, Node.js를 위한 Promise API를 활용하는 HTTP 비동기 통신 라이브러리입니다.\"</b><br>\r\n<br>\r\nAxios 공식문서에 나와 있는 Axios의 정의이다.<br>\r\n자바스크립트의 Fetch API와 비슷한 기능을 가지고 있다.\r\n\r\n## axios vs fetch\r\n\r\n<div class=\"table-wrapper\">\r\n  <table>\r\n    <tr>\r\n      <td>요청 객체에 URL을 가지고 있다.</td>\r\n      <td>요청 개체에 URL이 없다 .</td>\r\n    </tr>\r\n    <tr>\r\n      <td>쉽게 설치할 수 있는 독립 실행형 타사 패키지 이다.</td>\r\n      <td>대부분의 최신 브라우저에 내장되어 있다.<br>설치가 필요 없다.</td>\r\n    </tr>\r\n    <tr>\r\n      <td>내장된 XSRF 보호 기능 있다.</td"},{"title":"Vue Lifecycle 이해하기","author":"Jay.J","date":"2021-04-28T00:00:00.000Z","categories":["VueJs"],"tags":["javascript","vue.js","VueLifecycle"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/vuejs.png","url":"/post/2021-04-24-VueLifecycle","con":"---\r\n\r\n<br>\r\n\r\n## Vue Lifecycle 이해하기\r\n\r\n모든 Vue 앱은 Vue 함수로 새 Vue 인스턴스를 만드는 것부터 시작한다.\r\n\r\n```js\r\nvar vm = new Vue({\r\n  // 옵션\r\n})\r\n```\r\n\r\nVue 인스턴스는 생성될 때, 일련의 초기화 단계를 거친다.<br>\r\n예를들어 아래와 같은 경우가 있다.\r\n\r\n- 데이터 관찰 설정이 필요한 경우\r\n- 템플릿을 컴파일 하는 경우\r\n- 인스턴스를 DOM에 마운트하는 경우\r\n- 데이터가 변경되어 DOM을 업데이트 하는 경우\r\n\r\n<br>\r\n\r\n## 이미지로 보는 라이프 사이클\r\n\r\n<img src=\"/assets/img/vue/vue_lifecycle.png\" alt=\"\">\r\n\r\n<br>\r\n\r\n## 1. Create 단계\r\n라이프 사이클 훅에서 제일 처음 실행되는 Create 단계이다.<br>\r\nDOM이 생성되기 이전에 실행되는 훅으로써 DOM에 접근하거나 this.$el 을 사용하지 못한다.<br>"},{"title":"Vuex가 무엇인가?","author":"Jay.J","date":"2021-04-18T00:00:00.000Z","categories":["VueJs"],"tags":["javascript","vue.js","Vuex"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/vuejs.png","url":"/post/2021-04-18-Vuex","con":"---\r\n\r\n<br>\r\n\r\n## Vuex가 무엇인가?\r\n\r\nVue.js에 대한 상태 관리 패턴이자 라이브러리이다.<br>\r\n모든 컴포넌트에 대한 중앙 집중식 저장소 역할을 하며 예측 가능한 방식으로 상태를 변경할 수 있다.\r\n\r\n<br>\r\n\r\n## 상태 관리란?\r\n\r\n간단한 Vue 코드로 확인해보겠다.\r\n\r\n```js\r\nnew Vue({\r\n  // 상태\r\n  data () {\r\n    return {\r\n      count : 0\r\n    }\r\n  },\r\n  // 뷰\r\n  template : `\r\n    <div> {{ count }} </div>\r\n  `,\r\n  // 액션\r\n  methods: {\r\n    increment () {\r\n      this.count++\r\n    }\r\n  }\r\n})\r\n```\r\n\r\n- 상태(State) : 앱을 작동하는 소스이다.\r\n- 뷰(View) : 상태를 보여주는 매핑이다.\r\n- 액션(Actions) : 사용자 입력에 대해 반응적으로 대응한다.\r\n"},{"title":"Vue Router 사용하기","author":"Jay.J","date":"2021-04-10T00:00:00.000Z","categories":["VueJs"],"tags":["javascript","vue.js","vue Router"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/vuejs.png","url":"/post/2021-04-10-VueRouter","con":"---\r\n\r\n<br>\r\n\r\n## Vue Router 란\r\n\r\n'Vue 라우터는 Vue.js (opens new window)의 공식 라우터이며,<br>\r\nVue.js를 사용한 싱글 페이지 앱(SPA)을 쉽게 만들 수 있도록 Vue.js의 코어와 긴밀히 통합되어 있다.'<br>\r\n라고 공식문서에 설명되어있다.<br>\r\n<br>\r\n싱글 페이지 앱(SPA)는 최초에 한번 페이지를 로드하고 이후부터는 특정 부분만 변경하여 페이지를 보여주는 방식이다.<br>\r\n<br>\r\n기존의 웹 서비스는 서버로부터 데이터가 변경 및 페이지를 이동 할 때 화면 전체를 렌더링 하는 방식이였다.<br>\r\nSPA를 사용함으로써 전체 페이지를 렌더링하는데 드는 오버헤드가 줄어들어 앱의 속도가 향상되어 더 빠른 속도를 사용자에게 제공할 수 있다.<br>\r\n<br>\r\n즉, Vue Router를 사용하면 <b>싱글 페이지 앱(SPA)을 만드는 데 필요한 URL 이동 및 특정 부분의 변경</b>을 간단히 구현할 수 있다."},{"title":"Vue-CLI","author":"Jay.J","date":"2021-03-14T00:00:00.000Z","categories":["VueJs"],"tags":["javascript","vue.js"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/vuejs.png","url":"/post/2021-03-14-VueCLI","con":"---\r\n\r\n<br>\r\n\r\n## Vue-CLI 란\r\n\r\nVue CLI은 Vue.js의 개발 환경을 쉽고 빠르게 구축할 수 있도록 도와주는 도구이다.<br>\r\ncli를 이용하면, 짧은 시간내에 프로젝트의 환경을 설정할 수 있다.<br>\r\n사용자가 조금 더 개발에 집중할 수 있도록 도와준다.\r\n> CLI란 Command Line Interface의 약자로 터미널을 통해 사용자와 컴퓨터가 상호 작용하는 방식을 뜻한다.<br>\r\n> 즉, 작업 명령은 사용자가 툴바 키보드 등을 통해 문자열의 형태로 입력하며, 컴퓨터로부터의 출력 역시 문자열의 형태로 주어진다. - <a href=\"https://ko.wikipedia.org/wiki/%EB%AA%85%EB%A0%B9_%EC%A4%84_%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4\" target=\"_blank\">위키백과</a>\r\n\r\n<br>\r\n\r\n## Vue CLI 구성요소\r\n\r\nVue CLI는 여러 패키지로"},{"title":"Vue.js란","author":"Jay.J","date":"2021-03-05T00:00:00.000Z","categories":["VueJs"],"tags":["javascript","vue.js"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/vuejs.png","url":"/post/2021-03-05-whatIsVue.js","con":"---\r\n\r\n<br>\r\n\r\n## Vue.js 란 무엇인가?\r\n\r\nVue.js의 공식문서에서는 <b>'사용자 인터페이스를 만들기 위한 프로그레시브 프레임워크'</b> 라고 설명하고 있다.<br>\r\n즉, 보여지는 화면을 만드는 자바스크립트 프레임워크 중의 하나이다.<br>\r\nVue.js는 진입장벽이 낮으며 쉽고 빠르게 개발을 할 수 있다는 것이 가장 큰 장점으로 가지고 있다.<br>\r\n\r\n> <a href=\"https://kr.vuejs.org/v2/guide/index.html\" target=\"_blank\">Vue.js 공식사이트</a>\r\n\r\n<br>\r\n\r\n## 장점 및 특징\r\n\r\n### 학습곡선이 낮다.\r\n\r\nVue.js는 웹 개발을 단순화하고 정리하기 위해 개발된 대중적인 자바스크립트 프론트엔드 프레임워크이다.<br>\r\n수많은 프로젝트에서 AngularJS를 사용하여 구글을 위해 작업하던 Evan You에 의해 개발되었다.<br>\r\n웹 UI 개발(컴포넌트, 선언형 UI, 핫 리로딩"},{"title":"나를 괴롭히는 CORS","author":"Jay.J","date":"2020-12-20T00:00:00.000Z","categories":["html"],"tags":["html"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/CORS.png","url":"/post/2020-12-20-CORS","con":"---\r\n\r\n<br>\r\n\r\n## &nbsp;\r\n\r\n> 🚨 Access to XMLHttpRequest at 'http:// [A] ' from origin 'http:// [B] ' has been blocked by CORS policy : No 'Access-Control-Allow-Origin' header is present on the requested resource.\r\n\r\n웹 프로젝트를 구축하거나 운영하다보면 한번씩은 나타나는 오류이다.<br>\r\n그리고 생각보다 자주 나타나는 오류이기 때문에 누구나 한번쯤은 봤을거라고 생각한다.<br>\r\n그렇기에 한번 자세히 알고 넘어가야겠다고 생각해서 정리한다.<br>\r\n\r\n<br>\r\n\r\n## 교차 출처 리소스 공유(Cross-Origin Resource Sharing, CORS)\r\n\r\nCORS는 Cross-Origin Resource Sharing의 약자로 교차 출저 리소스 공유이다.<br>\r\n<br>\r\n<a href=\"https:"},{"title":"GET과 POST 방식","author":"Jay.J","date":"2020-09-28T00:00:00.000Z","categories":["HTTP"],"tags":["HTTP"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/http.png","url":"/post/2020-09-28-GetAndPost","con":"---\r\n\r\n<br>\r\n\r\n## &nbsp;\r\n\r\n웹 브라우저로 어떤 사이트에 접속한다고 했을 때, 사용자는 URL을 입력하여 접근한다.<br>\r\nHTTP 프로토콜을 통하여 사용자는 요청을 보내고 서버는 그 요청에 맞게 응답한다.<br>\r\n그리고 그 요청의 방식에는 크게 2가지 방식이 있고 그것이 바로 GET방식과 POST방식이다\r\n\r\n<br>\r\n\r\n## GET\r\n\r\nGET 방식은 서버로부터 어떠한 정보를 조회하기 위해서 사용되는 방식이다.<br>\r\nGET은 서버에게 요청할 때 URL에 요청을 담아 보낸다. <br>\r\nURL의 끝에 ? 를 통하여 요청을 하는데 요청의 파라미터가 여러 개일 경우 &을 이용하여 요청한다.<br>\r\n\r\n```\r\nwww.test.com/test?id=value&id2=value2&id3=value3\r\n```\r\n\r\n요청의 파라미터는 키와 값의 형식으로 보낸다.<br>\r\n위에 적은 url에서 키는 id이며, 값은 value으로 이루어진 문자열이다.<br>\r\n<"},{"title":"VanillaJs","author":"Jay.J","date":"2020-08-25T00:00:00.000Z","categories":["javascript"],"tags":["javascript","VanillaJs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/javaScript.png","url":"/post/2020-08-25-VanillaJs","con":"---\r\n\r\n<br>\r\n\r\n## Vanilla JS란?\r\nVanilla JS(바닐라 자바스크립트)란 어떠한 프레임워크와 라이브러리가 적용되지 않은 날 것의 자바스크립트를 바닐라 자바스크립트라고 한다.\r\n\r\n<br>\r\n\r\n## 왜 Vanilla JS 사용하는 것인가\r\n개인적인 생각이지만 배보다 배꼽이 커지는 상황도 많았던 것 같다.<br>\r\njQuery라는 DOM을 컨트롤 하는데에 있어서 매우 뛰어난 라이브러리가 있다.<br>\r\n하지만 특정한 곳에서 한번만 사용할 것인데 그를 위해 jQuery를 사용한다면 효율적인 면에서 떨어진다.<br>\r\njQuery 또한 자바스크립트의 라이브러리이기 때문에 순수한 자바스크립트보다 속도면에서 성능이 떨어진다.<br>\r\n<br>\r\n또한 이전까지의 자바스크립트 버전은 DOM에 접근하려면 jQuery에 비해 길게 작성해야했기에 조금 더 편리한 jQuery를 개발하는 데 편하고 좋았다고 생각한다.<br>\r\n\r\n```js\r\n// class가 item 인 요소"},{"title":"자바스크립트 엄격모드?","author":"Jay.J","date":"2020-06-11T00:00:00.000Z","categories":["javascript"],"tags":["javascript"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/javaScript.png","url":"/post/2020-06-11-use_strict","con":"---\r\n\r\n<br>\r\n\r\n## 자바스크립트 엄격모드란 ?\r\n\r\nECMAScript 5 에서 소개되었다.<br>\r\n기본으로 우리 사용하는 자바스크립트는 <b>\"느슨한모드(sloppy mode)\"</b>라고 불리며<br>\r\n문법이나 살짝 벗어나는 오류 정도는 조용히 무시하고 작동되었다.<br>\r\n<b>\"엄격한 모드(strict mod)\"</b>를 사용하면 조금 더 디테일하게 문법이나 오류를 잡아낸다.\r\n\r\n<br>\r\n\r\n## 엄격모드를 사용하려면\r\n\r\n사용법은 간단하다. <br>\r\n엄격모드를 사용하기 위해서는 스크립트를 작성하기 전 최상단에 '\"use strict\";'를 작성해준다<br>\r\n\r\n```js\r\n\r\n'use strict';\r\n\r\nfunction A(){\r\n  ...\r\n}\r\n\r\nvar b = 'hi';\r\n\r\n```\r\n\r\n## 무엇이 다른가\r\n\r\n엄격모드를 설명하면서 조금 더 디테일하게 문법과 오류를 잡아낸다고 설명했다.<br>\r\n\r\n```js\r\n// 느슨한 모드\r\n\r\nb = "},{"title":"Javascript에서의 This","author":"Jay.J","date":"2020-04-15T00:00:00.000Z","categories":["javascript"],"tags":["javascript"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/javaScript.png","url":"/post/2020-04-15-javascriptThis","con":"---\r\n\r\n<br>\r\n\r\n## Javascript에서의 This\r\n\r\nthis가 무엇이냐라고 누군가 물어봤을 때 의미 자체에 순간 망설였던 적이 있었다.<br>\r\n그래서 this는 무엇이고 어떻게 동작하는 지에 대해 포스팅 하려고 한다.\r\n\r\n## This 무엇이냐 넌\r\nthis. 자바스크립트의 this는 호출한 객체가 저장되어있는 속성이다.\r\n\r\n```js\r\nconsole.log(this);  // window\r\n```\r\n\r\n기본적으로 this는 window 객체의 정보를 저장하고 있다.<br>\r\n기본적으로 사용하는 메서드들 또한 상단에의 window를 통해 호출하기 때문이다.\r\n\r\n```js\r\nwindow.console.log(this);  // window\r\n```\r\n> console에 찍힌 window 객체를 자세히보기를 열어서 찾으면 console를 찾을 수 있을 것이다.\r\n\r\nwindow객체의 console 객체의 log 메서드를 통하여 호출하였기에 this는 windo"},{"title":"웹 접근성(견고성)","author":"Jay.J","date":"2020-03-22T00:00:00.000Z","categories":["html"],"tags":["html","Web Accessibility"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/accessibility.jpg","url":"/post/2020-03-22-webAccessibility_5","con":"---\r\n\r\n<br>\r\n\r\n## 운용의 용이성\r\n사용자 인터페이스 구성요소는 조작 가능하고 내비게이션 할 수 있어야 한다.\r\n\r\n- [4.1.1 마크업 오류 방지](#411-마크업-오류-방지)\r\n- [4.2.1 웹 애플리케이션 접근성 준수](#421-웹-애플리케이션-접근성-준수)\r\n\r\n<br>\r\n\r\n### 4.1.1 마크업 오류 방지\r\n마크업 언어의 요소는 열고 닫음, 중첩 관계 및 속성 선언에 오류가 없어야 한다.\r\n\r\n#### 1) 요소의 열고 닫음\r\n\r\n##### <b style='color:red'>잘못된 소스</b>\r\n```HTML\r\n<ul>\r\n  <li>목록</li>\r\n  <li>목록</li>\r\n  <li>목록</li>\r\n<p>내용</p>\r\n```\r\n\r\n##### <b style='color:blue'>잘된 소스</b>\r\n```HTML\r\n<ul>\r\n  <li>목록</li>\r\n  <li>목록</li>\r\n  <li>목록</li>\r\n</ul>\r\n<p>내용</p>\r\n```\r\n\r\n"},{"title":"웹 접근성(이해의 용이성)","author":"Jay.J","date":"2020-03-21T00:00:00.000Z","categories":["html"],"tags":["html","Web Accessibility"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/accessibility.jpg","url":"/post/2020-03-21-webAccessibility_4","con":"---\r\n\r\n<br>\r\n\r\n## 이해의 용이성\r\n콘텐츠는 이해할 수 있어야 한다.\r\n\r\n- [3.1.1 기본 언어 표시](#311-기본-언어-표시)\r\n- [3.2.1 사용자 요구에 따른 실행](#321-사용자-요구에-따른-실행)\r\n- [3.3.1 콘텐츠의 선형화](#331-콘텐츠의-선형화)\r\n- [3.3.2 표의 구성](#332-표의-구성)\r\n- [3.4.1 레이블 제공](#341-레이블-제공)\r\n- [3.4.2 오류 정정](#342-오류-정정)\r\n\r\n<br>\r\n\r\n### 3.1.1 기본 언어 표시\r\n주로 사용하는 언어를 명시해야 한다.\r\n\r\n```HTML\r\n<html lang=”ko”>\r\n```\r\n> HTML5\r\n\r\n<br>\r\n\r\n### 3.2.1 사용자 요구에 따른 실행\r\n사용자가 의도하지 않은 기능 (새 창, 초점 변화 등)은 실행되지 않아야 한다.\r\n\r\n#### 1) 페이지 진입시 뜨는 새 창(팝업)\r\n\r\n<img src=\"/assets/img/webAccessibility/"},{"title":"웹 접근성(운용의 용이성)","author":"Jay.J","date":"2020-03-14T00:00:00.000Z","categories":["html"],"tags":["html","Web Accessibility"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/accessibility.jpg","url":"/post/2020-03-14-webAccessibility_3","con":"---\r\n\r\n<br>\r\n\r\n## 운용의 용이성\r\n사용자 인터페이스 구성요소는 조작 가능하고 내비게이션 할 수 있어야 한다.\r\n\r\n- [2.1.1 키보드 사용 보장](#211-키보드-사용-보장)\r\n- [2.1.2 초점 이동](#212-초점-이동)\r\n- [2.1.3 조작 가능](#213-조작-가능)\r\n- [2.2.1 응답시간 조절](#221-응답시간-조절)\r\n- [2.2.2 정지 기능 제공](#222-정지-기능-제공)\r\n- [2.3.1 깜빡임과 번쩍임 사용 제한](#231-깜빡임과-번쩍임-사용-제한)\r\n- [2.4.1 반복 영역 건너뛰기](#241-반복-영역-건너뛰기)\r\n- [2.4.2 제목 제공](#242-제목-제공)\r\n- [2.4.3 적절한 링크 텍스트](#243-적절한-링크-텍스트)\r\n\r\n<br>\r\n\r\n### 2.1.1 키보드 사용 보장\r\n모든 기능은 키보드만으로도 사용할 수 있어야 한다. (PC웹)<br>\r\n터치(touch) 기반 모바일 기기의 모든 컨트롤은 누르기 동작으로 제어"},{"title":"웹 접근성(인식의 용이성)","author":"Jay.J","date":"2020-03-07T00:00:00.000Z","categories":["html"],"tags":["html","Web Accessibility"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/accessibility.jpg","url":"/post/2020-03-07-webAccessibility_2","con":"---\r\n\r\n<br>\r\n\r\n## 인식의 용이성\r\n모든 콘텐츠는 사용자가 인식할 수 있어야 한다.\r\n\r\n- [1.1.1 적절한 대체 텍스트 제공](#111-적절한-대체-텍스트-제공)\r\n- [1.2.1 자막 제공](#121-자막-제공)\r\n- [1.3.1 색에 무관한 콘텐츠 인식](#131-색에-무관한-콘텐츠-인식)\r\n- [1.3.2 명확한 지시사항 제공](#132-명확한-지시사항-제공)\r\n- [1.3.3 텍스트 콘텐츠의 명도 대비](#133-텍스트-콘텐츠의-명도-대비)\r\n- [1.3.4 자동 재생 금지](#134-자동-재생-금지)\r\n- [1.3.5 콘텐츠 간의 구분](#135-콘텐츠-간의-구분)\r\n\r\n<br>\r\n\r\n### 1.1.1 적절한 대체 텍스트 제공\r\n텍스트 아닌 콘텐츠는 그 의미나 용도를 이해할 수 있도록 대체 텍스트를 제공해야 한다.\r\n\r\n#### 1) 의미가 있는 이미지는 대체 텍스트를 제공한다.\r\n\r\n<img src=\"/assets/img/webAccessibility/n"},{"title":"웹 접근성이란","author":"Jay.J","date":"2020-02-29T00:00:00.000Z","categories":["html"],"tags":["html","Web Accessibility"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/accessibility.jpg","url":"/post/2020-02-29-webAccessibility_1","con":"---\r\n\r\n<br>\r\n\r\n## &nbsp;\r\n\r\n이전 회사에서 웹 접근성에 대해 공부를 했었다.<br>\r\n공부했던 내용을 정리해두면 좋겠다는 생각이 있었는데,<br>\r\n미루고 미루다가 이제 정리를 한다.\r\n\r\n## 웹 접근성(Web Accessibility)이란\r\n\r\n웹 접근성이란 어떠한 사용자가 접근을 하더라도, 동일한 정보를 제공할 수 있도록 보장하는 것이다.<br>\r\n즉, 장애인, 고령자등 모든 사람이 비장애인과 차별되지 않은 정보를 얻을 수 있어야한다.<br>\r\n간단한 예로 이미지가 제공된다고 했을 때, 시각적으로 불편한 사람은 이미지의 정보를 얻을 수 없다.<br>\r\n그렇기에 이미지에 대한 대체 텍스트가 제공되어 텍스트로 정보를 전달할 수 있어야한다.\r\n> 시각장애인의 경우, 사이트를 읽어주는 스크린리더라는 프로그램으로 정보에 접근한다.<br>\r\n> 스크린리더는 이미지를 읽어주지 못하기 때문에 이미지 태그의 alt 속성을 이용하여 대체 텍스트를 제공해야한다.\r\n\r\n<br>"},{"title":"Sass & SCSS 란?","author":"Jay.J","date":"2019-08-31T00:00:00.000Z","categories":["css"],"tags":["sass","scss","css"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/sass.png","url":"/post/2019-08-31-whatIsSass","con":"---\r\n\r\n<br>\r\n\r\n## &nbsp;\r\n\r\n최근 프론트쪽을 담당하는 직군의 기술 스택을 보면 Sass를 심심찮게 볼 수 있습니다.\r\n그래서 Sass는 무엇인가에 대해서 알아보려고 합니다.\r\n\r\n> 본 글에서는 Sass에 대해서만 알아보며, 문법과 컴파일 방법에 대해서는 다루지 않습니다.\r\n\r\n<br>\r\n\r\n## Sass 란?\r\nSass는 Syntactically Awesome Style Sheets의 약자이며,\r\nCSS를 우리가 조금 더 편하게 사용하기 위해 확장한 언어입니다.\r\n그러나 웹에서는 CSS만 직접 동작하기 때문에 Sass는 웹에서 사용하기 위해서는 컴파일을 해주어야 합니다.\r\n그러기에 Sass는 <b>CSS Preprocessor(CSS 전처리기)</b>라고 불립니다. \r\n> 전처리기 란?\r\n> 프로그램을 만들 때 소스파일 > 전처리기 -> 컴파일러 ->  실행파일 순으로 실행되는데,\r\n> <b>전처리기(Preprocessor)</b>는 소스 코딩을 한 후 컴파일"},{"title":"CI(codeigniter)의 MVC패턴 프로젝트 경험","author":"Jay.J","date":"2019-06-05T00:00:00.000Z","categories":["Architecture"],"tags":["Architecture","Design Pattern","Retrospect"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/codeigniter.png","url":"/post/2019-06-05-CodeigniterAndMVC_Use","con":"---\r\n\r\n<br>\r\n\r\n## CI(codeigniter)의 MVC패턴 프로젝트 후기\r\n\r\n회사에서 개발팀에 코드이그나이터를 도입하였다.<br>\r\n개발팀에 도입한다고 해서 사실 크게 관심이 없었으며,<br>\r\n큰 영향도 없을 것이라고 생각했다.<br>\r\n<br>\r\n하지만 퍼블리셔 입장에서도 기존의 방식과 조금씩 달랐고<br>\r\n하나씩 경험했던 내용을 기록해두려고 한다.<br>\r\n\r\n## Codeigniter란\r\n\r\nCodeigniter(이하 코드이그나이터)란 PHP로 작성된 웹 프레임워크다.<br>\r\nMVC패턴으로 동작한다.<br>\r\n> <a href=\"/blog/posts/%2Fpost%2F2019-05-09-whatIsMVC\" target=\"_blank\">MVC에 관한 포스팅</a>\r\n\r\n<br>\r\n\r\n## 기존의 방식과 달라진 퍼블리셔 업무\r\n\r\n기존의 방식과 제일 크게 달라졌던 점은 역시 MVC패턴을 사용함에 따른 변화이다.<br>\r\n\r\n<img src=\"/assets/im"},{"title":"MVC패턴에 대해서","author":"Jay.J","date":"2019-05-09T00:00:00.000Z","categories":["Architecture"],"tags":["Architecture","Design Pattern"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/mvc.jpg","url":"/post/2019-05-09-whatIsMVC","con":"---\r\n\r\n<br>\r\n\r\n## MVC 란\r\n\r\nMVC는 Model, View, Controller의 약자이다.<br>\r\nMVC는 사용자 인터페이스, 데이터 및 논리 제어를 구현하는데 널리 사용되는 소프트웨어 디자인 패턴이다.<br>\r\n소프트웨어의 비즈니스 로직과 화면을 구분하는데 중점을 두고 있다.<br>\r\n\r\n<img src=\"/assets/img/architecture/mvc.png\" alt=\"\" style=\"max-width:500px\">\r\n\r\nUser는 Controller에게 요청하고, Controller는 Model에게 명령을 보내고,<br>\r\nModel은 해당의 데이터를 View에게 제공하여, User는 View를 통해 정보를 얻을 수 있다.<br>\r\n<br>\r\n하나 하나의 기능을 자세히 살펴보면 아래와 같다.<br>\r\n<br>\r\n\r\n### Model\r\n\r\n모델(model)이란 어떠한 동작을 수행하는 코드를 말한다.<br>\r\n모델은 데이터가 무엇인지를 정의한다.<br>\r"},{"title":"Require.js 을 사용했던 프로젝트에 대한 회고","author":"Jay.J","date":"2019-02-10T00:00:00.000Z","categories":["javascript"],"tags":["javascript","AMD","require.js","Retrospect"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/javaScript.png","url":"/post/2019-02-10-requirejs_use","con":"---\r\n\r\n<br>\r\n\r\n## Require.js 을 사용했던 프로젝트에 대한 회고\r\n\r\n기존의 프로젝트를 진행할 때에는 필요한 기능을 전역 함수 파일에 추가하여 사용했다.<br>\r\n전역 파일에 기능을 추가하여 사용하다보니 기능이 늘어날 수록 코드는 복잡해져갔으며 <br>\r\n모든 페이지에서 불필요한 기능까지 전부 호출하는게 비효율적으로 느껴졌다.<br>\r\n<br>\r\n그렇기에 최근 알게 되었던 AMD/Require.js에 관심을 더욱 가지게 되었으며, <br>\r\n신규 프로젝트에 Require.js를 사용해보기 했다.<br>\r\n> <a href=\"/blog/posts/%2Fpost%2F2018-06-23-AMD_requirejs\">AMD / Require.js에 대한 포스팅</a>\r\n\r\n<br>\r\n\r\n### 프로젝트 초반\r\n\r\n디자인을 보고 퍼블리싱하며, 공통으로 쓰이는 기능과 특정 페이지에서 사용 되는 기능을 파악했다.<br>\r\n공통으로 쓰이는 기능들 가운데, 기존 전역 함수에 있었"},{"title":"HTTP 와 HTTPS, Status Code","author":"Jay.J","date":"2018-11-18T00:00:00.000Z","categories":["HTTP"],"tags":["HTTP"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/httphttps.jpg","url":"/post/2018-11-18-HTTP_HTTPS_Status_Code","con":"---\r\n\r\n<br>\r\n\r\n## &nbsp;\r\n  \r\n인터넷을 사용하다보면 HTTP와 HTTPS로 시작되는 주소를 볼 수 있다.    \r\n어떤 차이가 있어서 HTTP와 HTTPS를 나눠서 쓰는지 알아보려고 한다.  \r\n\r\n<br>\r\n\r\n### HTTP\r\nHTTP는 <b>Hyper Text Transfer Protocol</b>의 약자로  \r\nWorld Wide Web에서 사용되는 기본 프로토콜이며 이 프로토콜은 메시지가 형식화되고  \r\n전송되는 방법과 다양한 명령에 대한 응답으로 <b>웹 서버와 브라우저가 수행해야하는 작업을 정의</b>한다.  \r\n<br>\r\n  \r\n### HTTPS\r\nHTTPS는 <b>Hyper Text Transfer Protocol over Secure sockets layter</b>의 약자이다.  \r\n기존의 HTTP는 보안장치 없이 그대로 정보를 전송하기에 보안에 취약하다.  \r\n그 보안에 취약한 문제를 해결하고자 HTTP에 secure sockets lay"},{"title":"AMP Conference","author":"Jay.J","date":"2018-11-05T00:00:00.000Z","categories":["conference"],"tags":["conference"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/amp.jpg","url":"/post/2018-11-05-amp_conference","con":"---\r\n\r\n<br>\r\n\r\n## AMP(Accelerated Mobile Pages)\r\nAMP는 Accelerated Mobile Pages의 약자로 Google에서 만든 오픈소스이며,  \r\n웹 페이지를 빠르고 번개와 같이 즉시 로딩 될 수 있게  \r\n모바일 <b>웹의 성능을 높이기 위한 목적을 가지고 있는 오픈소스 라이브러리</b>다.\r\n  \r\n<br>\r\n  \r\n### AMP의 특징\r\nAMP의 특징으로는 <b>즉시 페이지를 로드한다는 큰 틀안에서 이루어진다</b>.  \r\n비동기 스크립트만을 이용하여 페이지의 성능을 개선하고,  \r\n이미지와 iframe 등도 다운로드 전에 크기와 위치를 잡아 성능을 개선한다.  \r\n또한 css를 인라인으로 작성하여 호출할 때 보다 페이지를 더 빠르게 로드한다.  \r\n> 추가적인 정보 : <a href=\"https://www.ampproject.org/ko/learn/about-how/\" target=\"_blank\">https://www.ampproj"},{"title":"Node.js 란?","author":"Jay.J","date":"2018-07-08T00:00:00.000Z","categories":["nodejs"],"tags":["nodejs"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/nodejs.png","url":"/post/2018-07-08-node_init","con":"---\r\n\r\n<br>\r\n\r\n## Node.js 란?\r\n\r\nJavaScript는 Browser에서 작동하는 JavaScript와 V8 JavaScript 엔진으로 빌드된 JavaScript 런타임 환경에서 돌아가는 JavaScript가 있다.  \r\n  \r\n<b>Node.js는 V8 JavaScript 엔진으로 빌드된 JavaScript 런타임 환경에서 돌아가는 JavaScript 이다.</b>  \r\n런타임 환경에서 JavaScript로 서버를 구성할 수 있는 것일 뿐, Node.js 자체는 서버가 아니다.  \r\n> node.js !== 서버  \r\n\r\n<br>\r\nBrowser에서 돌아가는 JavaScript와 런타임 환경에서 돌아가는 JavaScript는 차이가 있다.  \r\n한 가지의 차이를 예를 들면,  \r\nBrowser에서 돌아가는 JavaScript에서 전역객체는 window 이지만,  \r\n런타임 환경에서 돌아가는 JavaScript에서 전역객체는 global 이다.  \r\n  \r\n"},{"title":"AMD & require.js","author":"Jay.J","date":"2018-06-23T00:00:00.000Z","categories":["javascript"],"tags":["javascript","AMD","require.js"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/javaScript.png","url":"/post/2018-06-23-AMD_requirejs","con":"---\r\n\r\n<br>\r\n\r\n## AMD\r\n\r\nAMD(Asynchronous Module Definition)란 모듈을 정의하는 방법과 모듈이 필요할 때 비동기로 로딩하는 방법을 정의한 API 이다.\r\nAMD는 세 가지의 핵심 개념을 가지고 동작한다.\r\n<br>\r\n#### 1. 동적 로딩\r\n\r\n동적 로딩(Dynamic Loading, Lazy Loading)은 페이지 렌더링을 방해하지 않으면서 필요한 파일만 로딩할 수 있다.\r\n\r\n브라우저는 문서를 위에서 아래로 읽어내려오며, \\<script\\> 태그를 만나면 \\<script\\>의 HTTP 요청과 다운로드, 파싱(Parsing), 실행이 일어나는 동안 브라우저는 다른 동작을 하지 않는다.\r\n그로 인하여 페이지 렌더링은 느려지는데, 이를 최적화 하는 기법으로 \\<script\\> 태그를 \\<body\\> 태그의 마지막에 배치하는 방법이 있다.\r\n하지만 이 방법 또한 첫 렌더링과 첫 인터랙션에 필요하지 않은, 페이지에 필요한 모든 JavaSc"},{"title":"Javascript Call Stack and Event Loop","author":"Jay.J","date":"2018-05-11T00:00:00.000Z","categories":["javascript"],"tags":["javascript"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/javaScript.png","url":"/post/2018-05-11-Call_Stack_and_Event_Loop","con":"---\r\n\r\n<br>\r\n\r\n## Call Stack and Event Loop\r\n> 호출 스택 및 이벤트 루프\r\n\r\n<br>\r\n\r\n### 자바 스크립트 엔진\r\njavascript 를 해석하고 실행하는 인터프리터.\r\n> 인터프리터 : 프로그래밍 언어의 소스 코드를 바로 실행하는 컴퓨터 프로그램 또는 환경을 말한다.\r\n\r\n엔진에는 4가지로 구성되어있다.\r\n- [Heap](#heap)\r\n- [CallStack](#callstack)\r\n- [EventQueue](#eventqueue)\r\n- [EventLoop](#eventloop)\r\n\r\n<br>\r\n\r\n### Heap\r\n객체나 변수 값들이 들어가있는 영역으로 메모리의 할당이 일어나는 곳이다.\r\n\r\n<br>\r\n\r\n### CallStack\r\n\r\nCall Stack은 코드 실행에 따라 호출 스택(task)이 쌓이는 곳이다.<br>\r\n자바스크립트는 기본적으로 싱글 쓰레드 기반 언어이다.<br>\r\n따라서 코드 순서에 따라 호출 스택(task)이 쌓이"},{"title":"Javascript 실행 컨텍스트","author":"Jay.J","date":"2018-05-04T00:00:00.000Z","categories":["javascript"],"tags":["javascript"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/javaScript.png","url":"/post/2018-05-04-Execution_Context","con":"---\r\n\r\n<br>\r\n\r\n## Javascript 실행 컨텍스트\r\n\r\n<br>\r\n\r\n### 실행 컨테스트란\r\n\r\n자바스크립트가 실행될 때 생성되는 실행 단위를 실행 컨텍스트라고 부른다.  \r\n자바스크립트가 실행되면 함수들이 차곡차곡 <b>콜 스택(Call Stack)</b>이라 곳에 쌓이는데,  \r\n<b>실행 컨텍스트는 Call Stack에 쌓이는 하나하나의 실행 정보</b>이다.\r\n\r\n```js\r\n\r\nconsole.log('전역 스코프');\r\nfunction first(){\r\n  console.log('First Context');\r\n  second();\r\n}\r\nfunction second(){\r\n  console.log('Second Context');\r\n}\r\nfirst();\r\n\r\n// 컨텍스트 실행순서\r\n// 1. console.log('전역 스코프') 컨텍스트에 들어감  \r\n// 2. first함수가 컨텍스트에 들어감  \r\n// 3. second함수가 컨텍스트에 들어감\r\n/"},{"title":"How do you stop event propagation?","author":"Jay.J","date":"2018-04-09T00:00:00.000Z","categories":["javascript"],"tags":["javascript"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/javaScript.png","url":"/post/2018-04-09-stop_event_propagation","con":"---\r\n\r\n<br>\r\n\r\n## How do you stop event propagation?\r\n> 이벤트 전파를 어떻게 중지합니까?\r\n\r\n<br>\r\n\r\n### 이벤트 전파란?\r\n\r\n#### html\r\n```html\r\n<div class=\"boxDiv click01\">\r\n    <p>3</p>\r\n    <div class=\"boxDiv click02\">\r\n        <p>2</p>\r\n        <div class=\"boxDiv click03\">\r\n            <p>1</p>\r\n        </div>\r\n    </div>\r\n</div>\r\n<p class=\"result\"></p>\r\n```\r\n#### css\r\n```css\r\n.boxDiv{border:1px solid #000;padding:20px}\r\n.click01{width:300px;margin:0 50px;background:#aaa}\r\n.click02{background:#ddd}\r\n.click03{backg"},{"title":"Where do you place the JavaScript?","author":"Jay.J","date":"2018-03-29T00:00:00.000Z","categories":["javascript"],"tags":["javascript"],"math":"true","mermaid":"true","img":"/blogAPI/assets/img/javaScript.png","url":"/post/2018-03-29-Where_do_you_place_the_JavaScript","con":"---\r\n\r\n<br>\r\n\r\n## Where do you place the JavaScript?\r\n> JavaScript는 어디에 두어야합니까?\r\n\r\n<br>\r\n\r\n### 1. Head, Body\r\nhead Tag 섹션에 삽입하거나 body Tag 섹션의 시작 부분에 놓는 방법은 안좋다.  \r\n해당 부분에 위치시킬 경우 문서는 페이지 로드시  \r\n페이지를 읽다가 script Tag를 만날 경우 페이지의 분석을 멈추고  \r\n스크립트를 로드한 후 페이지를 읽기 때문에 성능면에서 안좋다.  \r\n<br>\r\n\r\n#### 브라우저가 웹 사이트를 로드 할 때 일어나는 일\r\n1. 문서 가져 온다 (예 : index.html, index.asp, main.php ...등)\r\n2. HTML 구문 분석한다.\r\n3. 파서는 문서를 위에서 부터 아래로 읽는다.  \r\n    중간에 외부 스크립트 파일을 참조하는 script Tag를 발견한다.\r\n4. 브라우저가 스크립트 파일을 확인하고 요청한다.  \r\n    "}]}